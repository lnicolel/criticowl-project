{"ast":null,"code":"//     wink-pos-tagger\n//     English Part-of-speech (POS) tagger\n//\n//     Copyright (C) 2017-19  GRAYPE Systems Private Limited\n//\n//     This file is part of “wink-pos-tagger”.\n//\n//     Permission is hereby granted, free of charge, to any person obtaining a\n//     copy of this software and associated documentation files (the \"Software\"),\n//     to deal in the Software without restriction, including without limitation\n//     the rights to use, copy, modify, merge, publish, distribute, sublicense,\n//     and/or sell copies of the Software, and to permit persons to whom the\n//     Software is furnished to do so, subject to the following conditions:\n//\n//     The above copyright notice and this permission notice shall be included\n//     in all copies or substantial portions of the Software.\n//\n//     THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS\n//     OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n//     FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL\n//     THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n//     LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING\n//     FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER\n//     DEALINGS IN THE SOFTWARE.\n\n/* eslint-disable no-console */\n//\nconst K = require('./rules/consts.js');\nvar posCRsGE0 = require('./rules/pos-rules-ge0.js');\nvar valueCRsGE0 = require('./rules/value-rules-ge0.js');\nvar posCRsLE0 = require('./rules/pos-rules-le0.js');\nvar valueCRsLE0 = require('./rules/value-rules-le0.js');\n\n// ### testValueAtDelta\n/**\n *\n * Tests the **value** of token's property defined by `rule.operand.property`\n * using regex `rule.matches` at `rule.operand.delta` away from `cti`.\n *\n * @param {object[]} tokens in wink-tokenizer standards.\n * @param {number} cti current token's index.\n * @param {object} rule containing keys `op`, `operand` and `matches` and their\n * corresponding values.\n * @return {boolean} `true` if match occurs otherwise `false`.\n * @private\n*/\nvar testValueAtDelta = function (tokens, cti, rule) {\n  var tAti = tokens[rule.operand.delta + cti];\n  if (tAti && rule.matches.test(tAti[rule.operand.property])) return true;\n  return false;\n}; // testValueAtDelta();\n\n// ### testValueInRange\n/**\n *\n * Tests the **value** of token's property defined by `rule.operand.property`\n * using regex `rule.matches` anywhere within the range specified by array\n * `rule.operand.range`. The array is a 2-element array specifying the range,\n * which is added to `cti` to compute the actual range.\n *\n * @param {object[]} tokens in wink-tokenizer standards.\n * @param {number} cti current token's index.\n * @param {object} rule containing keys `op`, `operand` and `matches` and their\n * corresponding values.\n * @return {boolean} `true` if match occurs otherwise `false`.\n * @private\n*/\nvar testValueInRange = function (tokens, cti, rule) {\n  var tAti;\n  for (var i = rule.operand.range[0]; i <= rule.operand.range[1]; i += 1) {\n    tAti = tokens[i + cti];\n    if (tAti && rule.matches.test(tAti[rule.operand.property])) return true;\n  }\n  return false;\n}; // testValueInRange()\n\nvar operation = Object.create(null);\noperation[K.TEST_VALUE_AT_DELTA] = testValueAtDelta;\noperation[K.TEST_VALUE_IN_RANGE] = testValueInRange;\n\n// ### applyContextRule\n/**\n *\n * Applies the given `contextRule` on the current token. A rule applicatin may\n * trigger change in the POS at token specified by `thenPosAt` relative distance.\n * The change is applied only if the new POS is amongst one of the valid POSes.\n *\n * @param {object[]} tokens in wink-tokenizer standards.\n * @param {number} cti current token's index.\n * @param {object} contextRule contains the specific rule.\n * @param {array[]} poses each element is an array & contains valid POSes for\n * the token at that index in `tokens`.\n * @return {boolean} `true` if pos change occurs otherwise `false`.\n * @private\n*/\nvar applyContextRule = function (tokens, cti, contextRule, poses) {\n  var rules = contextRule.rules;\n  var change = true;\n  for (var i = 0, imax = rules.length; i < imax && change; i += 1) {\n    change = operation[rules[i].op](tokens, cti, rules[i]);\n  }\n  // Trigger change only if the new `pos` is a valid one — present in `poses`.\n  if (change && poses[cti].indexOf(contextRule.willBe) !== -1) {\n    tokens[contextRule.thenPosAt + cti].pos = contextRule.willBe;\n    return true;\n  }\n  return false;\n}; // applyContextRule()\n\n// ### applyContextRules\n/**\n *\n * Applies given `contextRules` on each token one-by-one. For each token, rules\n * are tried until either a POS change has occurred or all rules have been exhausted\n * without any change.\n *\n * @param {object[]} tokens in wink-tokenizer standards.\n * @param {object} contextRules contains rules for different POSes. The rules to\n * be applied is selected on the basis of POS of the current token.\n * @param {array[]} poses each element is an array & contains valid POSes for\n * the token at that index in `tokens`.\n * @return {void} Nothing!\n * @private\n*/\nvar applyContextRules = function (tokens, contextRules, poses) {\n  var rules;\n  var i, imax, j, jmax;\n  for (i = 0, imax = tokens.length; i < imax; i += 1) {\n    rules = contextRules[tokens[i].pos];\n    if (rules) {\n      for (j = 0, jmax = rules.length; j < jmax && !applyContextRule(tokens, i, rules[j], poses); j += 1);\n    }\n  }\n}; // applyContextRules()\n\n// ### applyAllContextRules\n/**\n *\n * There are currently 4 sets of context rules. They are first categorized\n * on the basis of `property` of token they use i.e. **value** or **pos**. Each\n * one of them is further categorized on the basis of if the **delta/range** values\n * are **positive** or **negative**. It applies these rules in the required sequence.\n *\n * @param {object[]} tokens in wink-tokenizer standards.\n * @param {array[]} poses each element is an array & contains valid POSes for\n * the token at that index in `tokens`.\n * @return {void} Nothing!\n * @private\n*/\nvar applyAllContextRules = function (tokens, poses) {\n  // First apply <0 rules to update POS before looking ahead.\n  // Try `value` specific rules first followed by `pos` specific. In other words\n  // specific rules followed by generic rules.\n  applyContextRules(tokens, valueCRsLE0, poses);\n  applyContextRules(tokens, posCRsLE0, poses);\n  // Already applied <0 rules, time to look ahead.\n  applyContextRules(tokens, valueCRsGE0, poses);\n  applyContextRules(tokens, posCRsGE0, poses);\n}; // applyAllContextRules()\n\nmodule.exports = applyAllContextRules;","map":{"version":3,"names":["K","require","posCRsGE0","valueCRsGE0","posCRsLE0","valueCRsLE0","testValueAtDelta","tokens","cti","rule","tAti","operand","delta","matches","test","property","testValueInRange","i","range","operation","Object","create","TEST_VALUE_AT_DELTA","TEST_VALUE_IN_RANGE","applyContextRule","contextRule","poses","rules","change","imax","length","op","indexOf","willBe","thenPosAt","pos","applyContextRules","contextRules","j","jmax","applyAllContextRules","module","exports"],"sources":["C:/Users/cheko/Desktop/Education/Freelance/criticowl-main/criticowl_frontend/node_modules/wink-pos-tagger/src/rules-engine.js"],"sourcesContent":["//     wink-pos-tagger\n//     English Part-of-speech (POS) tagger\n//\n//     Copyright (C) 2017-19  GRAYPE Systems Private Limited\n//\n//     This file is part of “wink-pos-tagger”.\n//\n//     Permission is hereby granted, free of charge, to any person obtaining a\n//     copy of this software and associated documentation files (the \"Software\"),\n//     to deal in the Software without restriction, including without limitation\n//     the rights to use, copy, modify, merge, publish, distribute, sublicense,\n//     and/or sell copies of the Software, and to permit persons to whom the\n//     Software is furnished to do so, subject to the following conditions:\n//\n//     The above copyright notice and this permission notice shall be included\n//     in all copies or substantial portions of the Software.\n//\n//     THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS\n//     OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n//     FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL\n//     THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n//     LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING\n//     FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER\n//     DEALINGS IN THE SOFTWARE.\n\n/* eslint-disable no-console */\n//\nconst K = require( './rules/consts.js' );\n\nvar posCRsGE0 = require( './rules/pos-rules-ge0.js' );\nvar valueCRsGE0 = require( './rules/value-rules-ge0.js' );\nvar posCRsLE0 = require( './rules/pos-rules-le0.js' );\nvar valueCRsLE0 = require( './rules/value-rules-le0.js' );\n\n// ### testValueAtDelta\n/**\n *\n * Tests the **value** of token's property defined by `rule.operand.property`\n * using regex `rule.matches` at `rule.operand.delta` away from `cti`.\n *\n * @param {object[]} tokens in wink-tokenizer standards.\n * @param {number} cti current token's index.\n * @param {object} rule containing keys `op`, `operand` and `matches` and their\n * corresponding values.\n * @return {boolean} `true` if match occurs otherwise `false`.\n * @private\n*/\nvar testValueAtDelta = function ( tokens, cti, rule ) {\n  var tAti = tokens[ rule.operand.delta + cti ];\n  if ( tAti && rule.matches.test( tAti[ rule.operand.property ] ) ) return true;\n  return false;\n}; // testValueAtDelta();\n\n// ### testValueInRange\n/**\n *\n * Tests the **value** of token's property defined by `rule.operand.property`\n * using regex `rule.matches` anywhere within the range specified by array\n * `rule.operand.range`. The array is a 2-element array specifying the range,\n * which is added to `cti` to compute the actual range.\n *\n * @param {object[]} tokens in wink-tokenizer standards.\n * @param {number} cti current token's index.\n * @param {object} rule containing keys `op`, `operand` and `matches` and their\n * corresponding values.\n * @return {boolean} `true` if match occurs otherwise `false`.\n * @private\n*/\nvar testValueInRange = function ( tokens, cti, rule ) {\n  var tAti;\n  for ( var i = rule.operand.range[ 0 ]; i <= rule.operand.range[ 1 ]; i += 1 ) {\n    tAti = tokens[ i + cti ];\n    if ( tAti && rule.matches.test( tAti[ rule.operand.property ] ) ) return true;\n  }\n  return false;\n}; // testValueInRange()\n\nvar operation = Object.create( null );\noperation[ K.TEST_VALUE_AT_DELTA ] = testValueAtDelta;\noperation[ K.TEST_VALUE_IN_RANGE ] = testValueInRange;\n\n// ### applyContextRule\n/**\n *\n * Applies the given `contextRule` on the current token. A rule applicatin may\n * trigger change in the POS at token specified by `thenPosAt` relative distance.\n * The change is applied only if the new POS is amongst one of the valid POSes.\n *\n * @param {object[]} tokens in wink-tokenizer standards.\n * @param {number} cti current token's index.\n * @param {object} contextRule contains the specific rule.\n * @param {array[]} poses each element is an array & contains valid POSes for\n * the token at that index in `tokens`.\n * @return {boolean} `true` if pos change occurs otherwise `false`.\n * @private\n*/\nvar applyContextRule = function ( tokens, cti, contextRule, poses ) {\n  var rules = contextRule.rules;\n  var change = true;\n  for ( var i = 0, imax = rules.length; ( i < imax && change ); i += 1 ) {\n    change = operation[ rules[ i ].op ]( tokens, cti, rules[ i ] );\n  }\n  // Trigger change only if the new `pos` is a valid one — present in `poses`.\n  if ( change && poses[ cti ].indexOf( contextRule.willBe ) !== -1 ) {\n    tokens[ contextRule.thenPosAt + cti ].pos = contextRule.willBe;\n    return true;\n  }\n  return false;\n}; // applyContextRule()\n\n// ### applyContextRules\n/**\n *\n * Applies given `contextRules` on each token one-by-one. For each token, rules\n * are tried until either a POS change has occurred or all rules have been exhausted\n * without any change.\n *\n * @param {object[]} tokens in wink-tokenizer standards.\n * @param {object} contextRules contains rules for different POSes. The rules to\n * be applied is selected on the basis of POS of the current token.\n * @param {array[]} poses each element is an array & contains valid POSes for\n * the token at that index in `tokens`.\n * @return {void} Nothing!\n * @private\n*/\nvar applyContextRules = function ( tokens, contextRules, poses ) {\n  var rules;\n  var i, imax, j, jmax;\n  for ( i = 0, imax = tokens.length; i < imax; i += 1 ) {\n    rules = contextRules[ tokens[ i ].pos ];\n    if ( rules ) {\n      for ( j = 0, jmax = rules.length; j < jmax && !applyContextRule( tokens, i, rules[ j ], poses ); j += 1);\n    }\n  }\n}; // applyContextRules()\n\n// ### applyAllContextRules\n/**\n *\n * There are currently 4 sets of context rules. They are first categorized\n * on the basis of `property` of token they use i.e. **value** or **pos**. Each\n * one of them is further categorized on the basis of if the **delta/range** values\n * are **positive** or **negative**. It applies these rules in the required sequence.\n *\n * @param {object[]} tokens in wink-tokenizer standards.\n * @param {array[]} poses each element is an array & contains valid POSes for\n * the token at that index in `tokens`.\n * @return {void} Nothing!\n * @private\n*/\nvar applyAllContextRules = function ( tokens, poses ) {\n  // First apply <0 rules to update POS before looking ahead.\n  // Try `value` specific rules first followed by `pos` specific. In other words\n  // specific rules followed by generic rules.\n  applyContextRules( tokens, valueCRsLE0, poses );\n  applyContextRules( tokens, posCRsLE0, poses );\n  // Already applied <0 rules, time to look ahead.\n  applyContextRules( tokens, valueCRsGE0, poses );\n  applyContextRules( tokens, posCRsGE0, poses );\n}; // applyAllContextRules()\n\nmodule.exports = applyAllContextRules;\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"script","externalDependencies":[]}