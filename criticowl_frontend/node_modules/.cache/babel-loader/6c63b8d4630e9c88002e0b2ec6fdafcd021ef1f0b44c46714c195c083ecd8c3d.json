{"ast":null,"code":"//     wink-pos-tagger\n//     English Part-of-speech (POS) tagger\n//\n//     Copyright (C) 2017-19  GRAYPE Systems Private Limited\n//\n//     This file is part of “wink-pos-tagger”.\n//\n//     Permission is hereby granted, free of charge, to any person obtaining a\n//     copy of this software and associated documentation files (the \"Software\"),\n//     to deal in the Software without restriction, including without limitation\n//     the rights to use, copy, modify, merge, publish, distribute, sublicense,\n//     and/or sell copies of the Software, and to permit persons to whom the\n//     Software is furnished to do so, subject to the following conditions:\n//\n//     The above copyright notice and this permission notice shall be included\n//     in all copies or substantial portions of the Software.\n//\n//     THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS\n//     OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n//     FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL\n//     THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n//     LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING\n//     FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER\n//     DEALINGS IN THE SOFTWARE.\n\n//\n// Defines the morphological rules for guessing the POS for unknown words.\nvar unknownWordsPOS = require('wink-lexicon/src/unknown-words.js');\n\n// POS for `tag`!\nvar tagPOS = require('wink-lexicon/src/tags.js');\nvar words = require('wink-lexicon/src/wn-words.js');\nvar adjExceptions = require('wink-lexicon/src/wn-adjective-exceptions.js');\nvar nounExceptions = require('wink-lexicon/src/wn-noun-exceptions.js');\nvar verbExceptions = require('wink-lexicon/src/wn-verb-exceptions.js');\nvar senseMap = require('wink-lexicon/src/wn-word-senses.js');\n\n// POS for punctuations.\nvar punctuationPOS = require('wink-lexicon/src/punctuations.js');\nconst rgxs4POS = [\n// 0-2: NNS/VBZ\n{\n  replace: /s$/,\n  by: ''\n}, {\n  replace: /es$/,\n  by: ''\n}, {\n  replace: /ies$/,\n  by: 'y'\n},\n// 3-4: VBG\n{\n  replace: /ing$/,\n  by: ''\n}, {\n  replace: /ing$/,\n  by: 'e'\n},\n// 5-6: VBD/VBN\n{\n  replace: /ed$/,\n  by: ''\n}, {\n  replace: /d$/,\n  by: ''\n},\n// 7-8: JJR\n{\n  replace: /er$/,\n  by: ''\n}, {\n  replace: /r$/,\n  by: ''\n},\n// 9-10: JJS\n{\n  replace: /est$/,\n  by: ''\n}, {\n  replace: /st$/,\n  by: ''\n},\n// Balance: NNS\n{\n  replace: /xes$/,\n  by: 'x'\n}, {\n  replace: /zes$/,\n  by: 's'\n}, {\n  replace: /ves$/,\n  by: 'f'\n}, {\n  replace: /ches$/,\n  by: 'ch'\n}, {\n  replace: /shes$/,\n  by: 'sh'\n}, {\n  replace: /men$/,\n  by: 'man'\n}];\n\n// ### isPotentialWord\n/**\n *\n * Checks if the supplied `word` is potentially a valid English word by\n * applying regexes sequentially and performaling a level-2 look up.\n *\n * @param {string} word that needs to be checked\n * @return {boolean} true if it is a potential English word, otherwise false.\n * @private\n*/\nvar isPotentialWord = function (word) {\n  for (var i = 0, imax = rgxs4POS.length; i < imax; i += 1) {\n    if (rgxs4POS[i].replace.test(word)) {\n      if (words[word.replace(rgxs4POS[i].replace, rgxs4POS[i].by)] !== undefined) return true;\n    }\n  }\n  return false;\n};\n\n// ### unigramL2POSTagger\n/**\n *\n * Tags a single input `token` whose lookup has failed in the `lexicon`. Attempts\n * to apply morphological rules if token is found in the level-2 lookup.\n * Finally falls bact to NNP!\n *\n * @param {object} token that needs to be tagged; must follow wink-tokenizer.\n * standards.\n * @param {object} lexicon containing word/pos key/value pairs.\n * @return {array} the array of all possible part-of-speeches.\n * @private\n*/\nvar unigramL2POSTagger = function (token, lexicon) {\n  var word = token.normal;\n  var index = words[word];\n  var pos;\n  if (index || adjExceptions[word] || nounExceptions[word] || verbExceptions[word] || isPotentialWord(word)) {\n    if (index && senseMap[index][0] === 15 && /^[A-Z][a-z]+/.test(token.value)) {\n      pos = 'NNP';\n    } else {\n      // Word exists, can apply morphological rules safely.\n      // Their sequence of application is important: match the longest\n      // one first!\n      pos = unknownWordsPOS[word.slice(-4)] || unknownWordsPOS[word.slice(-3)] || unknownWordsPOS[word.slice(-2)] || unknownWordsPOS[word.slice(-1)];\n      if (!pos && word.slice(0, 2) === 'un' && lexicon[word.slice(2)]) {\n        pos = 'JJ';\n      }\n    }\n  } else {\n    // Seems like an unknown word, make it proper noun!\n    pos = 'NNP';\n  }\n  // Return poses intelligently to allow the context rules to work!\n  return pos === undefined ? ['NN', 'VBP', 'VB'] : pos === 'NNS' ? ['NNS', 'VBZ'] : pos === 'VBN' ? ['VBD', 'VBN'] : [pos];\n}; // unigramL2POSTagger()\n\n// ### unigramPOSTagger\n/**\n *\n * Tags a single input `token` using the `lexicon`. Attempts to apply\n * morphological rules if the primary look up fails but secondary one succeeds.\n * Finally falls bact to NNP!\n *\n * @param {object} token that needs to be tagged; must follow wink-tokenizer.\n * standards.\n * @param {object} lexicon containing word/pos key/value pairs.\n * @return {array} the array of all possible part-of-speeches.\n * @private\n*/\nvar unigramPOSTagger = function (token, lexicon) {\n  // If token is an **entity with pos defined**, no tagging is needed.\n  if (token.entityType && token.pos) return [token.pos];\n  // Use `normalize()` to obtain the word and not `toLowerCase()`.\n  var word = token.normal;\n  // Arrray of pos for the word from lexicon.\n  var poses;\n  // Finish off with punctuations first.\n  if (token.tag === 'punctuation') {\n    // `|| token.value` is a catch all clause! In other words, unknown\n    // punctuation will have a pos as **it's value**.\n    token.pos = punctuationPOS[token.value] || token.value;\n    return [token.pos];\n  }\n  if (token.tag === 'symbol' && token.value !== '&') {\n    token.pos = 'NN';\n    return [token.pos];\n  }\n  // Start with tag lookup!\n  token.pos = tagPOS[token.tag];\n  if (token.pos === undefined) {\n    // Didn't work, try dictionary lookup.\n    poses = lexicon[word] || unigramL2POSTagger(token, lexicon);\n    token.pos = poses[0];\n  } else {\n    // Tag POS is returned.\n    return [token.pos];\n  }\n  // The `poses` can be undefined in case of unknown words, un-adjectives & NN fallback.\n  return poses;\n}; // unigramPOSTagger();\n\nmodule.exports = unigramPOSTagger;","map":{"version":3,"names":["unknownWordsPOS","require","tagPOS","words","adjExceptions","nounExceptions","verbExceptions","senseMap","punctuationPOS","rgxs4POS","replace","by","isPotentialWord","word","i","imax","length","test","undefined","unigramL2POSTagger","token","lexicon","normal","index","pos","value","slice","unigramPOSTagger","entityType","poses","tag","module","exports"],"sources":["C:/Users/cheko/Desktop/Education/Freelance/criticowl-main/criticowl_frontend/node_modules/wink-pos-tagger/src/unigram-tagger.js"],"sourcesContent":["//     wink-pos-tagger\n//     English Part-of-speech (POS) tagger\n//\n//     Copyright (C) 2017-19  GRAYPE Systems Private Limited\n//\n//     This file is part of “wink-pos-tagger”.\n//\n//     Permission is hereby granted, free of charge, to any person obtaining a\n//     copy of this software and associated documentation files (the \"Software\"),\n//     to deal in the Software without restriction, including without limitation\n//     the rights to use, copy, modify, merge, publish, distribute, sublicense,\n//     and/or sell copies of the Software, and to permit persons to whom the\n//     Software is furnished to do so, subject to the following conditions:\n//\n//     The above copyright notice and this permission notice shall be included\n//     in all copies or substantial portions of the Software.\n//\n//     THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS\n//     OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n//     FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL\n//     THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n//     LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING\n//     FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER\n//     DEALINGS IN THE SOFTWARE.\n\n//\n// Defines the morphological rules for guessing the POS for unknown words.\nvar unknownWordsPOS = require( 'wink-lexicon/src/unknown-words.js' );\n\n// POS for `tag`!\nvar tagPOS = require( 'wink-lexicon/src/tags.js' );\nvar words = require( 'wink-lexicon/src/wn-words.js' );\nvar adjExceptions = require( 'wink-lexicon/src/wn-adjective-exceptions.js' );\nvar nounExceptions = require( 'wink-lexicon/src/wn-noun-exceptions.js' );\nvar verbExceptions = require( 'wink-lexicon/src/wn-verb-exceptions.js' );\nvar senseMap = require( 'wink-lexicon/src/wn-word-senses.js' );\n\n// POS for punctuations.\nvar punctuationPOS = require( 'wink-lexicon/src/punctuations.js' );\n\nconst rgxs4POS = [\n  // 0-2: NNS/VBZ\n  { replace: /s$/, by: '' },\n  { replace: /es$/, by: '' },\n  { replace: /ies$/, by: 'y' },\n  // 3-4: VBG\n  { replace: /ing$/, by: '' },\n  { replace: /ing$/, by: 'e' },\n  // 5-6: VBD/VBN\n  { replace: /ed$/, by: '' },\n  { replace: /d$/, by: '' },\n  // 7-8: JJR\n  { replace: /er$/, by: '' },\n  { replace: /r$/, by: '' },\n  // 9-10: JJS\n  { replace: /est$/, by: '' },\n  { replace: /st$/, by: '' },\n  // Balance: NNS\n  { replace: /xes$/, by: 'x' },\n  { replace: /zes$/, by: 's' },\n  { replace: /ves$/, by: 'f' },\n  { replace: /ches$/, by: 'ch' },\n  { replace: /shes$/, by: 'sh' },\n  { replace: /men$/, by: 'man' }\n];\n\n// ### isPotentialWord\n/**\n *\n * Checks if the supplied `word` is potentially a valid English word by\n * applying regexes sequentially and performaling a level-2 look up.\n *\n * @param {string} word that needs to be checked\n * @return {boolean} true if it is a potential English word, otherwise false.\n * @private\n*/\nvar isPotentialWord = function ( word ) {\n  for ( var i = 0, imax = rgxs4POS.length; i < imax; i += 1 ) {\n    if ( rgxs4POS[ i ].replace.test( word ) ) {\n      if ( words[ word.replace( rgxs4POS[ i ].replace, rgxs4POS[ i ].by ) ] !== undefined ) return true;\n    }\n  }\n\n  return false;\n};\n\n// ### unigramL2POSTagger\n/**\n *\n * Tags a single input `token` whose lookup has failed in the `lexicon`. Attempts\n * to apply morphological rules if token is found in the level-2 lookup.\n * Finally falls bact to NNP!\n *\n * @param {object} token that needs to be tagged; must follow wink-tokenizer.\n * standards.\n * @param {object} lexicon containing word/pos key/value pairs.\n * @return {array} the array of all possible part-of-speeches.\n * @private\n*/\nvar unigramL2POSTagger = function ( token, lexicon ) {\n  var word = token.normal;\n  var index = words[ word ];\n  var pos;\n  if ( index || adjExceptions[ word ] || nounExceptions[ word] || verbExceptions[ word ] || isPotentialWord( word ) ) {\n    if ( index && senseMap[ index ][ 0 ] === 15 && ( /^[A-Z][a-z]+/ ).test( token.value ) ) {\n      pos = 'NNP';\n    } else {\n      // Word exists, can apply morphological rules safely.\n      // Their sequence of application is important: match the longest\n      // one first!\n      pos = ( unknownWordsPOS[ word.slice( -4 ) ] ||\n              ( unknownWordsPOS[ word.slice( -3 ) ] ||\n                ( unknownWordsPOS[ word.slice( -2 ) ] ||\n                    unknownWordsPOS[ word.slice( -1 ) ] ) ) );\n      if ( !pos && word.slice( 0, 2 ) === 'un' && lexicon[ word.slice( 2 ) ] ) {\n        pos = 'JJ';\n      }\n    }\n  } else {\n    // Seems like an unknown word, make it proper noun!\n    pos = 'NNP';\n  }\n  // Return poses intelligently to allow the context rules to work!\n  return ( ( pos === undefined ) ?\n            [ 'NN', 'VBP', 'VB' ] : ( pos === 'NNS' ) ?\n              [ 'NNS', 'VBZ' ] : ( pos === 'VBN' ) ?\n                  [ 'VBD', 'VBN' ] : [ pos ]\n         );\n}; // unigramL2POSTagger()\n\n// ### unigramPOSTagger\n/**\n *\n * Tags a single input `token` using the `lexicon`. Attempts to apply\n * morphological rules if the primary look up fails but secondary one succeeds.\n * Finally falls bact to NNP!\n *\n * @param {object} token that needs to be tagged; must follow wink-tokenizer.\n * standards.\n * @param {object} lexicon containing word/pos key/value pairs.\n * @return {array} the array of all possible part-of-speeches.\n * @private\n*/\nvar unigramPOSTagger = function ( token, lexicon ) {\n  // If token is an **entity with pos defined**, no tagging is needed.\n  if ( token.entityType && token.pos ) return [ token.pos ];\n  // Use `normalize()` to obtain the word and not `toLowerCase()`.\n  var word = token.normal;\n  // Arrray of pos for the word from lexicon.\n  var poses;\n  // Finish off with punctuations first.\n  if ( token.tag === 'punctuation' ) {\n    // `|| token.value` is a catch all clause! In other words, unknown\n    // punctuation will have a pos as **it's value**.\n    token.pos = punctuationPOS[ token.value ] || token.value;\n    return [ token.pos ];\n  }\n  if ( token.tag === 'symbol' && token.value !== '&' ) {\n    token.pos = 'NN';\n    return [ token.pos ];\n  }\n  // Start with tag lookup!\n  token.pos = tagPOS[ token.tag ];\n  if ( token.pos === undefined ) {\n    // Didn't work, try dictionary lookup.\n    poses = lexicon[ word ] || unigramL2POSTagger( token, lexicon );\n    token.pos = poses[ 0 ];\n  } else {\n    // Tag POS is returned.\n    return [ token.pos ];\n  }\n  // The `poses` can be undefined in case of unknown words, un-adjectives & NN fallback.\n  return ( poses );\n}; // unigramPOSTagger();\n\nmodule.exports = unigramPOSTagger;\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"script","externalDependencies":[]}