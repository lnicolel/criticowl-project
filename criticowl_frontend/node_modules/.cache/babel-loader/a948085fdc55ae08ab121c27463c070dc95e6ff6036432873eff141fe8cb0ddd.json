{"ast":null,"code":"//     wink-nlp\n//\n//     Copyright (C) GRAYPE Systems Private Limited\n//\n//     This file is part of “wink-nlp”.\n//\n//     Permission is hereby granted, free of charge, to any\n//     person obtaining a copy of this software and\n//     associated documentation files (the \"Software\"), to\n//     deal in the Software without restriction, including\n//     without limitation the rights to use, copy, modify,\n//     merge, publish, distribute, sublicense, and/or sell\n//     copies of the Software, and to permit persons to\n//     whom the Software is furnished to do so, subject to\n//     the following conditions:\n//\n//     The above copyright notice and this permission notice\n//     shall be included in all copies or substantial\n//     portions of the Software.\n//\n//     THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF\n//     ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED\n//     TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A\n//     PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL\n//     THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,\n//     DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF\n//     CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN\n//     CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER\n//     DEALINGS IN THE SOFTWARE.\n\n//\n\nvar DocDataWrapper = require('./dd-wrapper.js');\nvar Automata = require('./automaton.js');\nvar mappers = require('./tokens-mappers.js');\nvar mapRawTokens2UIdOfValue = mappers.mapRawTokens2UIdOfValue;\nvar mapRawTokens2UIdOfNormal = mappers.mapRawTokens2UIdOfNormal;\nvar cerAutomata = Automata(); // eslint-disable-line new-cap\n\nvar rgxOr = /^\\[((?:[^| ]+\\|)+?|(?:\\|[^| ]+)+?|(?:[^| ]+\\|[^| ]+)+?|(?:[^| ]+))\\]$/;\nvar rgxPipe = /\\|/g;\n\n// ## mergeSplitsAndMatches\n/**\n * Helper function to merge the two input array elements by picking elements\n * alternatively from each array.\n * @param  {string[]} splts obtained by splitting on pipe.\n * @param  {string[]} mtchs obtained by matching on pipe.\n * @return {string[]}       the merged array.\n * @private\n */\nvar mergeSplitsAndMatches = function (splts, mtchs) {\n  const [s0, ...splits] = splts;\n  return s0 === undefined ? mtchs : [s0, ...mergeSplitsAndMatches(mtchs, splits)];\n}; // mergeSplitsAndMatches()\n\n// # compiler\n/**\n * It transforms the input patterns for custom entity recognition into a model,\n * which is run by winkNLP's `readDoc()` method. The model is created by\n * the `learnCustomEntities()` method of core winkNLP using this compiler. Brefore\n * the compiler can be **run**, its instance must be created using the following\n * parameters:\n *\n * @param  {JSON}     cerModel    precompiled custom entity meta model — handles escaping\n *                                of entity literals. For example `^ADJ` will match\n *                                with token `ADJ` (or `adj` based on `matchValue` in\n *                                `cerConfig`), whereas `ADJ` will match with the\n *                                adjective part-of-speech of a token.\n * @param  {object}   cache       of lexicon, which is required to deliver performance.\n * @param  {function} tokenize    is instantiated from core tokenizer, which tokenises the\n *                                input patterns. It is used in the `tokenizeText()` private\n *                                method of compiler.\n * @param  {boolean}  matchValue  match value flag — defines match on either `value` or\n *                                `normal` of tokens.<br/>\n * @return {object}               contains **run** function, which can compile the input\n *                                pattern into a model.\n * @private\n */\nvar compiler = function (cerModel, cache, tokenize, matchValue) {\n  // Returned!\n  var methods = Object.create(null);\n  // Map of literals to be preserved.\n  var preserve;\n  cerAutomata.importJSON(cerModel);\n  // On pattern detection, we need to save the custom property — `preserve`\n  // created by the `cerModel's` execution.\n  cerAutomata.setOnPatternDetectionFn((match, customProperty) => match.push(customProperty));\n\n  // ## hasOrPattern\n  /**\n   * Test the presence of or-pattern in the tokens and returns the index of the\n   * same.\n   * @param  {string[]} tokens of each word, split on spaces.\n   * @return {number}          the index where token is found otherwise -1.\n   * @private\n   */\n  var hasOrPattern = function (tokens) {\n    // Use findIndex with regex to locate.\n    return tokens.findIndex(e => rgxOr.test(e)) !== -1;\n  }; // hasOrPattern()\n\n  // ## encloseInSquareBracket\n  /**\n   * Heper function to enclose incoming text element within square brackets.\n   * @param  {string} e input text element.\n   * @return {string}   enclosed text element.\n   * @private\n   */\n  var encloseInSquareBracket = function (e) {\n    // Enclose!\n    return '[' + e + ']';\n  }; // encloseInSquareBracket()\n\n  // ## tokenizeText\n  /**\n   * Tokenizes the incoming text using wink-nlp's tokenizer.\n   * @param  {string} text   input text string.\n   * @return {object[]}      where each object contains normal & value of the token.\n   * @private\n   */\n  var tokenizeText = function (text) {\n    // Mimic wink-nlp like manoeuvre!\n    var rdd = Object.create(null);\n    rdd.cache = cache;\n    rdd.tokens = [];\n    var wrappedDocData = DocDataWrapper(rdd); // eslint-disable-line new-cap\n\n    tokenize(wrappedDocData, text); // eslint-disable-line new-cap\n    const tokens = [];\n    const values = mapRawTokens2UIdOfValue(rdd).map(t => cache.value(t));\n    const normals = mapRawTokens2UIdOfNormal(rdd).map(t => cache.value(t));\n    for (let i = 0; i < values.length; i += 1) tokens.push({\n      value: values[i],\n      normal: normals[i]\n    });\n    return tokens;\n  }; // tokenizeText()\n\n  // ## compileSimplePattern\n  /**\n   * Compiles a simple pattern.\n   *\n   * @param  {string} text    input simple pattern string.\n   * @return {string[]}       of compiled pattern.\n   * @private\n   */\n  var compileSimplePattern = function (text) {\n    // Compiled pattern build here.\n    const cp = [];\n    // Tokenized `text`.\n    const tokens = tokenizeText(text);\n    // Spans of recognized patterns from tokens' value because patterns are always\n    // in UPPER case.\n    const spans = cerAutomata.recognize(tokens.map(t => t.value));\n    // The spans are mapped into `replacements` and are indexed by `spans[ i ][ 0 ]`.\n    // `e[ 0 ]` & e[ 1 ] are start & end indexes, `e[ 2 ]` is entity name, and\n    // `e[ 3 ]` is customProperty, where true mean preserve replacement.\n    const replacements = Object.create(null);\n    spans.forEach(e => replacements[e[0]] = [e[1], e[2], e[3]]);\n    // Perform replacements.\n    for (let i = 0; i < tokens.length; i += 1) {\n      // Replacement defined for this index — `i`? **Yes** means it could be a property\n      // or esacped property or a lone escape character or an esacped escape character. **No**\n      // means a literal.\n      if (replacements[i]) {\n        // **Empty** entity name indicates a lone escape character.\n        if (replacements[i][1] !== '') {\n          // Preserve? **Yes** means it is an escaped property or escape char;\n          // **No** means property.\n          if (replacements[i][2].preserve) {\n            // Since it has to be preserved, `matchValue` drives both the `cp` &\n            // `preserve` contents i.e. **normal** or **value**\n\n            // This contains escaped `<property>`.\n            const tri0 = matchValue ? tokens[replacements[i][0]].value : tokens[replacements[i][0]].normal;\n            // This conntains `<property>&`.\n            const ri1 = matchValue ? replacements[i][1] : replacements[i][1].toLowerCase();\n            // Map escaped `<property>` to `<property>&`.\n            preserve[tri0] = ri1;\n            cp.push(ri1);\n          } else {\n            // It is a **property**, therefore it has to go to the state machine\n            // **as-is**.\n            cp.push(replacements[i][1]);\n          }\n        }\n        // Skip by moving `i` to the end index.\n        i = replacements[i][0];\n      } else {\n        // **Literal**: Extract token's normal or value based on `matchValue` flag.\n        const ti = matchValue ? tokens[i].value : tokens[i].normal;\n        cp.push(ti);\n        preserve[ti] = ti;\n      }\n    }\n    // Return compiled pattern.\n    return cp;\n  }; // compileSimplePattern()\n\n  // ## compileOrPattern\n  /**\n   * Compiles the tokens containing \"or\" patterns.\n   * @param  {string[]} tokens  contains the incoming tokens.\n   * @return {string}           compiled text string.\n   * @private\n   */\n  var compileOrPattern = function (tokens) {\n    const pattern = [];\n    for (let i = 0; i < tokens.length; i += 1) {\n      if (rgxOr.test(tokens[i])) {\n        // Strip the opening/closing square brackets.\n        const ti = tokens[i].substring(1, tokens[i].length - 1);\n        // Find matches with `rgxPipe`; if they are null set to an empty array.\n        const matches = ti.match(rgxPipe) || [];\n        // Find splits on `rgxPipe`.\n        const splits = ti.split(rgxPipe);\n        // Iterate through `splits` to check that each element cannot be tokenized\n        // further.\n        for (let j = 0; j < splits.length; j += 1) {\n          const st = splits[j] === '' ? [''] : compileSimplePattern(splits[j]);\n          if (st.length > 1) {\n            throw Error(`wink-nlp: incorrect token \"${st.join('')}\" encountered in examples of learnCustomEntities() API.`);\n          }\n          splits[j] = st[0];\n        } // splits iterations\n        // Merge matches & splits to create the pattern.\n        pattern.push(encloseInSquareBracket(mergeSplitsAndMatches(splits, matches).join('')));\n      } else {\n        // Simple part of text, just enclose it in square brackets after replacement (if any).\n        compileSimplePattern(tokens[i]).forEach(t => pattern.push(encloseInSquareBracket(t)));\n      }\n    }\n    return pattern.join(' ');\n  }; // compileOrPattern()\n\n  // ## compileSinglePattern\n  /**\n   * Compiles a single pattern text. It invokes compilation of \"or\" or \"simple\"\n   * pattern based on input text type.\n   *\n   * @param  {string} text      input pattern text.\n   * @return {(array|string)}   depending onn type of pattern.\n   * @private\n   */\n  var compileSinglePattern = function (text) {\n    // Split on spaces.\n    const atoms = text.trim().split(/\\s+/);\n    // Invoke required compilation based on the type of `atoms` i.e. the text.\n    if (hasOrPattern(atoms)) {\n      return compileOrPattern(atoms);\n    }\n    return compileSimplePattern(text);\n  }; // compileSinglePattern()\n\n  // ## run\n  /**\n   * Runs the compiler to compile the examples. It calls `compileSinglePattern()`\n   * on each example iteratively.\n   *\n   * @param  {object[]} examples containing objects, where each object defines an\n   *                             entity in terms of name and pattern.\n   * @return {object}            compiled examples ready for automata and literals\n   *                             preserve.\n   * @private\n   */\n  var run = function (examples) {\n    // Compiled examples are captured here.\n    const ces = [];\n    // Intialize preserve every time a new compilation happens.\n    preserve = Object.create(null);\n    for (let i = 0; i < examples.length; i += 1) {\n      const example = examples[i];\n      const patterns = example.patterns;\n      for (let j = 0; j < patterns.length; j += 1) {\n        const cp = compileSinglePattern(patterns[j]);\n        const ce = Object.create(null);\n        ce.name = example.name;\n        ce.pattern = cp;\n        if (example.mark) ce.mark = example.mark;\n        ces.push(ce);\n      }\n    }\n    return {\n      examples: ces,\n      preserve: preserve\n    };\n  }; // run()\n\n  methods.run = run;\n  return methods;\n}; // compiler()\n\nmodule.exports = compiler;","map":{"version":3,"names":["DocDataWrapper","require","Automata","mappers","mapRawTokens2UIdOfValue","mapRawTokens2UIdOfNormal","cerAutomata","rgxOr","rgxPipe","mergeSplitsAndMatches","splts","mtchs","s0","splits","undefined","compiler","cerModel","cache","tokenize","matchValue","methods","Object","create","preserve","importJSON","setOnPatternDetectionFn","match","customProperty","push","hasOrPattern","tokens","findIndex","e","test","encloseInSquareBracket","tokenizeText","text","rdd","wrappedDocData","values","map","t","value","normals","i","length","normal","compileSimplePattern","cp","spans","recognize","replacements","forEach","tri0","ri1","toLowerCase","ti","compileOrPattern","pattern","substring","matches","split","j","st","Error","join","compileSinglePattern","atoms","trim","run","examples","ces","example","patterns","ce","name","mark","module","exports"],"sources":["C:/Users/cheko/Desktop/Education/Freelance/criticowl-main/criticowl_frontend/node_modules/wink-nlp/src/examples-compiler.js"],"sourcesContent":["//     wink-nlp\n//\n//     Copyright (C) GRAYPE Systems Private Limited\n//\n//     This file is part of “wink-nlp”.\n//\n//     Permission is hereby granted, free of charge, to any\n//     person obtaining a copy of this software and\n//     associated documentation files (the \"Software\"), to\n//     deal in the Software without restriction, including\n//     without limitation the rights to use, copy, modify,\n//     merge, publish, distribute, sublicense, and/or sell\n//     copies of the Software, and to permit persons to\n//     whom the Software is furnished to do so, subject to\n//     the following conditions:\n//\n//     The above copyright notice and this permission notice\n//     shall be included in all copies or substantial\n//     portions of the Software.\n//\n//     THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF\n//     ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED\n//     TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A\n//     PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL\n//     THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,\n//     DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF\n//     CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN\n//     CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER\n//     DEALINGS IN THE SOFTWARE.\n\n//\n\nvar DocDataWrapper = require( './dd-wrapper.js' );\nvar Automata = require( './automaton.js' );\nvar mappers = require( './tokens-mappers.js' );\nvar mapRawTokens2UIdOfValue = mappers.mapRawTokens2UIdOfValue;\nvar mapRawTokens2UIdOfNormal = mappers.mapRawTokens2UIdOfNormal;\n\nvar cerAutomata = Automata(); // eslint-disable-line new-cap\n\nvar rgxOr = /^\\[((?:[^| ]+\\|)+?|(?:\\|[^| ]+)+?|(?:[^| ]+\\|[^| ]+)+?|(?:[^| ]+))\\]$/;\nvar rgxPipe = /\\|/g;\n\n// ## mergeSplitsAndMatches\n/**\n * Helper function to merge the two input array elements by picking elements\n * alternatively from each array.\n * @param  {string[]} splts obtained by splitting on pipe.\n * @param  {string[]} mtchs obtained by matching on pipe.\n * @return {string[]}       the merged array.\n * @private\n */\nvar mergeSplitsAndMatches = function ( splts, mtchs ) {\n  const [ s0, ...splits ] = splts;\n  return ( ( s0 === undefined ) ? mtchs : [ s0, ...mergeSplitsAndMatches( mtchs, splits ) ] );\n}; // mergeSplitsAndMatches()\n\n// # compiler\n/**\n * It transforms the input patterns for custom entity recognition into a model,\n * which is run by winkNLP's `readDoc()` method. The model is created by\n * the `learnCustomEntities()` method of core winkNLP using this compiler. Brefore\n * the compiler can be **run**, its instance must be created using the following\n * parameters:\n *\n * @param  {JSON}     cerModel    precompiled custom entity meta model — handles escaping\n *                                of entity literals. For example `^ADJ` will match\n *                                with token `ADJ` (or `adj` based on `matchValue` in\n *                                `cerConfig`), whereas `ADJ` will match with the\n *                                adjective part-of-speech of a token.\n * @param  {object}   cache       of lexicon, which is required to deliver performance.\n * @param  {function} tokenize    is instantiated from core tokenizer, which tokenises the\n *                                input patterns. It is used in the `tokenizeText()` private\n *                                method of compiler.\n * @param  {boolean}  matchValue  match value flag — defines match on either `value` or\n *                                `normal` of tokens.<br/>\n * @return {object}               contains **run** function, which can compile the input\n *                                pattern into a model.\n * @private\n */\nvar compiler = function ( cerModel, cache, tokenize, matchValue ) {\n  // Returned!\n  var methods = Object.create( null );\n  // Map of literals to be preserved.\n  var preserve;\n\n  cerAutomata.importJSON( cerModel );\n  // On pattern detection, we need to save the custom property — `preserve`\n  // created by the `cerModel's` execution.\n  cerAutomata.setOnPatternDetectionFn( ( match, customProperty ) => ( match.push( customProperty ) ) );\n\n  // ## hasOrPattern\n  /**\n   * Test the presence of or-pattern in the tokens and returns the index of the\n   * same.\n   * @param  {string[]} tokens of each word, split on spaces.\n   * @return {number}          the index where token is found otherwise -1.\n   * @private\n   */\n  var hasOrPattern = function ( tokens ) {\n    // Use findIndex with regex to locate.\n    return ( tokens.findIndex( ( e ) => rgxOr.test( e ) ) !== -1 );\n  }; // hasOrPattern()\n\n  // ## encloseInSquareBracket\n  /**\n   * Heper function to enclose incoming text element within square brackets.\n   * @param  {string} e input text element.\n   * @return {string}   enclosed text element.\n   * @private\n   */\n  var encloseInSquareBracket = function ( e ) {\n    // Enclose!\n    return '[' + e +  ']';\n  }; // encloseInSquareBracket()\n\n  // ## tokenizeText\n  /**\n   * Tokenizes the incoming text using wink-nlp's tokenizer.\n   * @param  {string} text   input text string.\n   * @return {object[]}      where each object contains normal & value of the token.\n   * @private\n   */\n  var tokenizeText = function ( text ) {\n    // Mimic wink-nlp like manoeuvre!\n    var rdd = Object.create( null );\n    rdd.cache = cache;\n    rdd.tokens = [];\n    var wrappedDocData = DocDataWrapper( rdd );  // eslint-disable-line new-cap\n\n    tokenize( wrappedDocData, text ); // eslint-disable-line new-cap\n    const tokens = [];\n    const values = mapRawTokens2UIdOfValue( rdd ).map( ( t ) => cache.value( t ) );\n    const normals = mapRawTokens2UIdOfNormal( rdd ).map( ( t ) => cache.value( t ) );\n    for ( let i = 0; i < values.length; i += 1 ) tokens.push( { value: values[ i ], normal: normals[ i ] } );\n    return tokens;\n  }; // tokenizeText()\n\n  // ## compileSimplePattern\n  /**\n   * Compiles a simple pattern.\n   *\n   * @param  {string} text    input simple pattern string.\n   * @return {string[]}       of compiled pattern.\n   * @private\n   */\n  var compileSimplePattern = function ( text ) {\n    // Compiled pattern build here.\n    const cp = [];\n    // Tokenized `text`.\n    const tokens = tokenizeText( text );\n    // Spans of recognized patterns from tokens' value because patterns are always\n    // in UPPER case.\n    const spans = cerAutomata.recognize( tokens.map( ( t ) => t.value ) );\n    // The spans are mapped into `replacements` and are indexed by `spans[ i ][ 0 ]`.\n    // `e[ 0 ]` & e[ 1 ] are start & end indexes, `e[ 2 ]` is entity name, and\n    // `e[ 3 ]` is customProperty, where true mean preserve replacement.\n    const replacements = Object.create( null );\n    spans.forEach( ( e ) => ( replacements[ e[ 0 ] ] = [ e[ 1 ], e[ 2 ], e[ 3 ] ] ) );\n    // Perform replacements.\n    for ( let i = 0; i < tokens.length; i += 1 ) {\n      // Replacement defined for this index — `i`? **Yes** means it could be a property\n      // or esacped property or a lone escape character or an esacped escape character. **No**\n      // means a literal.\n      if ( replacements[ i ] ) {\n        // **Empty** entity name indicates a lone escape character.\n        if ( replacements[ i ][ 1 ] !==  '' ) {\n          // Preserve? **Yes** means it is an escaped property or escape char;\n          // **No** means property.\n          if ( replacements[ i ][ 2 ].preserve ) {\n            // Since it has to be preserved, `matchValue` drives both the `cp` &\n            // `preserve` contents i.e. **normal** or **value**\n\n            // This contains escaped `<property>`.\n            const tri0 = ( matchValue ) ? tokens[ replacements[ i ][ 0 ] ].value : tokens[ replacements[ i ][ 0 ] ].normal;\n            // This conntains `<property>&`.\n            const ri1 = ( matchValue ) ? replacements[ i ][ 1 ] : replacements[ i ][ 1 ].toLowerCase();\n            // Map escaped `<property>` to `<property>&`.\n            preserve[ tri0 ] = ri1;\n            cp.push( ri1 );\n          } else {\n            // It is a **property**, therefore it has to go to the state machine\n            // **as-is**.\n            cp.push( replacements[ i ][ 1 ] );\n          }\n        }\n        // Skip by moving `i` to the end index.\n        i = replacements[ i ][ 0 ];\n      } else {\n        // **Literal**: Extract token's normal or value based on `matchValue` flag.\n        const ti = ( matchValue ) ? tokens[ i ].value : tokens[ i ].normal;\n        cp.push( ti );\n        preserve[ ti ] = ti;\n      }\n    }\n    // Return compiled pattern.\n    return cp;\n  }; // compileSimplePattern()\n\n  // ## compileOrPattern\n  /**\n   * Compiles the tokens containing \"or\" patterns.\n   * @param  {string[]} tokens  contains the incoming tokens.\n   * @return {string}           compiled text string.\n   * @private\n   */\n  var compileOrPattern = function ( tokens ) {\n    const pattern = [];\n    for ( let i = 0; i < tokens.length; i += 1 ) {\n      if ( rgxOr.test( tokens[ i ] ) ) {\n        // Strip the opening/closing square brackets.\n        const ti = tokens[ i ].substring( 1, tokens[ i ].length - 1 );\n        // Find matches with `rgxPipe`; if they are null set to an empty array.\n        const matches = ti.match( rgxPipe ) || [];\n        // Find splits on `rgxPipe`.\n        const splits = ti.split( rgxPipe );\n        // Iterate through `splits` to check that each element cannot be tokenized\n        // further.\n        for ( let j = 0; j < splits.length; j += 1 ) {\n          const st = ( splits[ j ] === '' ) ? [ '' ] : compileSimplePattern( splits[ j ] );\n          if ( st.length > 1 ) {\n           throw Error( `wink-nlp: incorrect token \"${st.join( '' )}\" encountered in examples of learnCustomEntities() API.` );\n          }\n          splits[ j ] = st[ 0 ];\n        } // splits iterations\n        // Merge matches & splits to create the pattern.\n        pattern.push( encloseInSquareBracket( mergeSplitsAndMatches( splits, matches ).join( '' ) ) );\n      } else {\n        // Simple part of text, just enclose it in square brackets after replacement (if any).\n        compileSimplePattern( tokens[ i ] ).forEach( ( t ) => pattern.push( encloseInSquareBracket( t ) ) );\n      }\n    }\n    return pattern.join( ' ' );\n  }; // compileOrPattern()\n\n  // ## compileSinglePattern\n  /**\n   * Compiles a single pattern text. It invokes compilation of \"or\" or \"simple\"\n   * pattern based on input text type.\n   *\n   * @param  {string} text      input pattern text.\n   * @return {(array|string)}   depending onn type of pattern.\n   * @private\n   */\n  var compileSinglePattern = function ( text ) {\n    // Split on spaces.\n    const atoms = text.trim().split( /\\s+/ );\n    // Invoke required compilation based on the type of `atoms` i.e. the text.\n    if ( hasOrPattern( atoms ) ) {\n      return compileOrPattern( atoms );\n    }\n    return compileSimplePattern( text );\n  }; // compileSinglePattern()\n\n  // ## run\n  /**\n   * Runs the compiler to compile the examples. It calls `compileSinglePattern()`\n   * on each example iteratively.\n   *\n   * @param  {object[]} examples containing objects, where each object defines an\n   *                             entity in terms of name and pattern.\n   * @return {object}            compiled examples ready for automata and literals\n   *                             preserve.\n   * @private\n   */\n  var run = function ( examples ) {\n    // Compiled examples are captured here.\n    const ces = [];\n    // Intialize preserve every time a new compilation happens.\n    preserve = Object.create( null );\n    for ( let i = 0; i < examples.length; i += 1 ) {\n      const example = examples[ i ];\n      const patterns = example.patterns;\n      for ( let j = 0; j < patterns.length; j += 1 ) {\n        const cp = compileSinglePattern( patterns[ j ] );\n        const ce = Object.create( null );\n        ce.name = example.name;\n        ce.pattern = cp;\n        if ( example.mark ) ce.mark = example.mark;\n        ces.push( ce );\n      }\n    }\n\n    return { examples: ces, preserve: preserve };\n  }; // run()\n\n  methods.run = run;\n\n  return methods;\n}; // compiler()\n\nmodule.exports = compiler;\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"script","externalDependencies":[]}