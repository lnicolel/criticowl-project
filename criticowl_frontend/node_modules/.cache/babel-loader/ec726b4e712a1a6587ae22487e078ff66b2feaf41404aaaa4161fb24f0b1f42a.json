{"ast":null,"code":"//     wink-nlp\n//\n//     Copyright (C) GRAYPE Systems Private Limited\n//\n//     This file is part of “wink-nlp”.\n//\n//     Permission is hereby granted, free of charge, to any\n//     person obtaining a copy of this software and\n//     associated documentation files (the \"Software\"), to\n//     deal in the Software without restriction, including\n//     without limitation the rights to use, copy, modify,\n//     merge, publish, distribute, sublicense, and/or sell\n//     copies of the Software, and to permit persons to\n//     whom the Software is furnished to do so, subject to\n//     the following conditions:\n//\n//     The above copyright notice and this permission notice\n//     shall be included in all copies or substantial\n//     portions of the Software.\n//\n//     THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF\n//     ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED\n//     TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A\n//     PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL\n//     THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,\n//     DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF\n//     CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN\n//     CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER\n//     DEALINGS IN THE SOFTWARE.\n\n//\n\n/* eslint-disable no-console */\n/* eslint-disable guard-for-in */\nconst composePatterns = require('./compose-patterns.js');\nconst identifyMarkedArea = require('./identify-marked-area.js');\nconst eosTokenN = 2070000;\nconst eosTokenX = '$%^EoS^%$';\nconst otherwiseN = 2070003;\nconst otherwiseX = ' otherwise';\nvar simpleFSM = function (cache, token2Ignore) {\n  // Returned!\n  var methods = Object.create(null);\n  // Holds FSM in the following structure:<br/>\n  // curr state —> event —> next state <br/>\n  // One of the event is `otherwise`, whose next state defines the default state.\n  var fsm = Object.create(null);\n  // The root or the beginning state of the `fsm`.\n  const root = 0;\n  // Tracks the last used state. Whenever a new state is needed, its value is\n  // incremented and returned. See `getNextState()`.\n  var lastUsedState = 0;\n  // The terminal states i.e. the detected patterns: maps state to name.\n  var terminalStates = Object.create(null);\n  // The terminal states, where part of pattern has been marked out.\n  var markedStates = Object.create(null);\n  // Add-ons value is stored here.\n  var customPropertyAtStates = Object.create(null);\n  // Use to substitute tokens by patterns in a multi-pass scenario.\n  var substitutions;\n  // On pattern detection function.\n  var onPatternDetectionFn;\n  // By default always ignore the new line character, else use the value supplied\n  // by `token2Ignore`; this will usually be the OOV lexeme, i.e. `$%^oov^%$`.\n  const toBeIgnoredToken = token2Ignore === undefined ? '\\n' : token2Ignore;\n  // The `cache` is `undefined`, when things have to work on token text — for\n  // learning & recognition both. For native case of learning (i.e. generation),\n  // it can be `null` or real value; and native mode recognition will always\n  // need real value of the `cache`.\n  // Setup `keyLF/eosToken` to use during entity detection on the basis of `cache`\n  // value — It is critical for model generation.\n  const keyLF = cache === undefined || cache === null ? toBeIgnoredToken : cache.lookup(toBeIgnoredToken)[0];\n  const eosToken = cache === undefined || cache === null ? eosTokenX : eosTokenN;\n  // The `otherwise` event; including a space to ensure that such an input can\n  // never arrive from the token stream. Later on it will be changed to numeric\n  // value > `0xFFFFF` i.e. the limit of vocabulary.\n  const otherwise = cache === undefined ? otherwiseX : otherwiseN;\n\n  // ## getNextState\n  /**\n   *\n   * Returns the next state to be assigned i.e. the next unused state or\n   * a state corresponding to target, if defined.\n   *\n   * @param {number} index of current token.\n   * @param {number} last index of last token.\n   * @param {number} target state of the pattern being processed; could be\n   * `undefined` if it is being encountered for the first time.\n   * @returns {number} next state that should be assigned for the current event.\n   * @private\n  */\n  var getNextState = function (index, last, target) {\n    // Check its invocation in the of fsm.\n    if (index === last && target) return target;\n    // Compute next unused state & return. Note this now becomes the last\n    // used state!\n    lastUsedState += 1;\n    return lastUsedState;\n  }; // getNextState()\n\n  // ## learnSinglePattern\n  /**\n   *\n   * Learns a single pattern.\n   *\n   * @param {string} name of the pattern to be learned.\n   * @param {array} pattern to be learned.\n   * @param {array} mark `[ start, end ]`.\n   * @param {any} customProperty contains definable value(s).\n   * @returns {undefined} Nothing!\n   * @private\n  */\n  var learnSinglePattern = function (name, pattern, mark, customProperty) {\n    const length = pattern.length;\n    // Last element.\n    const last = length - 1;\n    // Target state for this pattern, would be `undefined` if this pattern type is\n    // enountered for the first time (`undefined` disables collapse of states).\n    const target = undefined;\n    // Tracks the `state` as the FSM builds up, specially useful if there are\n    // machines with shared path i.e. common `(state, events)` pairs.\n    let state = root;\n    // Assigned for `otherwise` events.\n    let goBackTo = root;\n    // Temp for event & next state.\n    let ev, nextState;\n\n    // Iterate through the pattern's tokens, while discovering any existing\n    // machine that can share path.\n    for (let k = 0; k < length; k += 1) {\n      ev = pattern[k];\n      // Create new state & intialize, if required.\n      if (fsm[state] === undefined) {\n        fsm[state] = Object.create(null);\n        fsm[state][otherwise] = goBackTo;\n      }\n      // Check for machines that may share path.\n      if (fsm[state][ev] === undefined) {\n        // None found, create new state transition by assigning the next state for\n        // the current event – `ev`.\n        nextState = getNextState(k, last, target);\n        fsm[state][ev] = nextState;\n        // Always compute state transition from the perspective of discovering\n        // shared path: here the `fsm[ state ][ ev ]` has been just assigned\n        // `nextState`, therefore `state` needs to transition to this state only.\n        state = nextState;\n      } else if (terminalStates[fsm[state][ev]]) {\n        // Case when shared path is found and the next state on the path is a\n        // terminal state.\n        if (fsm[state][otherwise] === root) fsm[state][otherwise] = goBackTo;\n        goBackTo = fsm[state][ev];\n        nextState = getNextState(k, last, target);\n        fsm[state][ev] = nextState;\n        // Compute state transition; again like earlier case, it would be `nextState`.\n        state = nextState;\n      } else if (k === last) {\n        // Case when shared path is found and the next state on the path is NOT\n        // a terminal state AND current token is the LAST one.\n        nextState = getNextState(k, last, target);\n        fsm[fsm[state][ev]][otherwise] = nextState;\n        state = nextState;\n      } else {\n        // Case when shared path is found and the next state on the path is NOT\n        // a terminal state AND current token is NOT the LAST one.<br/>\n        // Simply compute state transition, no other work to be done!\n        state = fsm[state][ev];\n      }\n    }\n    terminalStates[state] = name;\n    if (mark) {\n      // Update last element of `mark` to simplifies computations during fsm\n      // execution. Update must happen as a deep copy & not directly!\n      markedStates[state] = identifyMarkedArea(mark, length);\n    }\n    if (customProperty !== undefined) {\n      customPropertyAtStates[state] = customProperty;\n    }\n  }; // learnSinglePattern()\n\n  // ## learn\n  /**\n   *\n   * Learns the patterns that must be detected via recognize() API calls.\n   *\n   * @param {Object[]} patterns to be learned.\n   *\n   * @param {string} patterns[].name of the pattern.\n   * @param {string} patterns[].structure of the pattern.\n   * @returns {number} of uniquely named patterns.\n   * `[ pattern-id, start-token, end-token ]` format.\n   * @private\n  */\n  var learn = function (patterns) {\n    // Temp for counting unique.\n    var obj = Object.create(null);\n    // Composed Patterns\n    var cp = [];\n    for (let i = 0; i < patterns.length; i += 1) {\n      const pi = patterns[i];\n      if (typeof pi.pattern === 'string') {\n        const all = composePatterns(pi.pattern);\n        for (let j = 0; j < all.length; j += 1) cp.push({\n          name: pi.name,\n          pattern: all[j],\n          mark: pi.mark,\n          customProperty: pi.customProperty\n        });\n      } else cp.push({\n        name: pi.name,\n        pattern: pi.pattern,\n        mark: pi.mark,\n        customProperty: pi.customProperty\n      });\n    }\n    // Sort to get the longest pattern on the top.\n    cp.sort((a, b) => b.pattern.length - a.pattern.length);\n    // All set, now learn using composed patterns – `cp`!\n    for (let i = 0; i < cp.length; i += 1) {\n      learnSinglePattern(cp[i].name, cp[i].pattern, cp[i].mark, cp[i].customProperty);\n    }\n    // Return number of uniquely named patterns.\n    for (const ts in terminalStates) obj[terminalStates[ts]] = true;\n    return Object.keys(obj).length;\n  }; // learn()\n\n  // ## setOnPatternDetectionFn\n  /**\n   *\n   * Defines the function that is called on every detected pattern, provided\n   * the detected pattern had an `customProperty` property defined.\n   * @param {function} f to be called with `match` & `customProperty` value as parameters.\n   * @returns {boolean} `true` if it was a success otherwise `false`.\n   * @private\n  */\n  var setOnPatternDetectionFn = function (f) {\n    if (typeof f === 'function') {\n      onPatternDetectionFn = f;\n      return true;\n    }\n    return false;\n  }; // setOnPatternDetectionFn()\n\n  // ## pushMatch2Patterns\n  /**\n   *\n   * Pushes a `match`ed pattern details into the `patterns` array after handling\n   * marking and calling the on pattern detection function, if required. Before\n   * pushing a `match` to patterns, the state (numeric) at `match[ 2 ]` is mapped\n   * to its name using `terminalStates`; remember the `state` passed here is\n   * always the terminal state. Passing state in match ensures that respective\n   * `mark` and `customProperty` are handled differently if they have different values in\n   * a state-machine rows, even though the `names` are identical.\n   *\n   * @param {array} patterns where the `match` is pushed.\n   * @param {array} match pushed in to the `patterns`. The `match` conntains\n   * 3-entries viz. 0—state, 1 & 2—start & end indexes of `tokens`.\n   * @returns {undefined} Nothing.\n   * @private\n  */\n  var pushMatch2Patterns = function (patterns, match) {\n    // Extract the state at match[ 0 ].\n    var m0 = match[2];\n    // Pattern name `'0'` — simply ignore it!\n    if (terminalStates[m0] === '0') return;\n    // Not to be ignored — process it.\n    var mark = markedStates[m0];\n    var customProperty = customPropertyAtStates[m0];\n    if (mark) {\n      match[0] += mark[0];\n      match[1] -= mark[1];\n    }\n\n    // Removed `customProperty !== undefined &&` check while coding pos experiment\n    if (onPatternDetectionFn) onPatternDetectionFn(match, customProperty);\n    match[2] = terminalStates[m0];\n    patterns.push(match);\n  }; // pushPattern()\n\n  // ## setPatternSwap\n  /**\n   *\n   * Sets up the patterns to be used for token substitution/swap in the\n   * `recognize()` api.\n   *\n   * @param {array[]} patterns to be used for substitutions in `recognize()`.\n   * @returns {undefined} Nothing.\n   * @private\n  */\n  var setPatternSwap = function (patterns) {\n    if (!patterns || !Array.isArray(patterns)) {\n      substitutions = undefined;\n      return;\n    }\n    // Old `substitutions` are re-initialized.\n    substitutions = Object.create(null);\n    // Sort patterns by the start of pattern index.\n    patterns.sort((a, b) => a[0] > b[0]);\n    // Index it by start of pattern.\n    patterns.forEach(e => substitutions[e[0]] = [e[1], e[2]]);\n  }; // setPatternSwap()\n\n  // ## recognize\n  /**\n   *\n   * Recognizes patterns present in the input tokens in a greedy manner.\n   *\n   * @param {array} tokens in which the patterns need to be recognized.\n   * @param {function} [transformToken] an optional function that is called before\n   * processing every token.\n   * @param {*} [param] that has to be passed as the last param to `transformToken()`\n   * function.\n   * @returns {array[]} where each element follows\n   * `[ pattern-id, start-token, end-token ]` format.\n   * @private\n  */\n  var recognize = function (tokens, transformToken, param) {\n    // Length of the `tokens.`\n    const length = tokens.length;\n    // Check if `transformToken` is a valid function.\n    var transformTokenFn = typeof transformToken === 'function' ? transformToken : null;\n    // Detected patterns are captured here. Each element has the following format: <br/>\n    // `[ pattern-id, start-token, end-token ]`\n    var patterns = [];\n    // We don't need a separate state machines unlike `recognize()`, as the\n    // following set of variables together act like a singleton machine.\n    var first = 0;\n    var state = root;\n    // Next State.\n    var ns = root;\n    // Temp. for a single pattern.\n    var p = null;\n    // Last non-root otherwise state & index\n    var lastOtherwiseIndex;\n    var lastOtherwiseState;\n    // Temp. for a token.\n    var t;\n    // Used to increment `j` and computing span of pattern correctly, may become\n    // > 1 if an earlier detected pattern is longer that 1-token.\n    var delta = 1;\n    for (let i = 0; i <= length; i += 1) {\n      // **Attempt greedy lookup**:<br/>\n      // Keep digging until next state becomes `root` or a terminal state is\n      // encountered. Upon failure after a partial match, roll back is required\n      // so that the extra consumed tokens can be explored by machine.\n      for (let j = i; j <= length; j += delta) {\n        // Extract current token.\n        t = j === length ? eosToken : tokens[j];\n\n        // Skip the newline character; TODO: will replace by the hash value!\n        // Use direct hash for the time being later, it must be obtained via cache\n        if (t === keyLF) continue; // eslint-disable-line no-continue\n\n        // Perform replacements using earlier detected patterns.\n        if (substitutions && substitutions[j]) {\n          t = substitutions[j][1];\n          delta = substitutions[j][0] - j + 1;\n        } else delta = 1;\n\n        // Apply token transformation function, if defined. Must not be called\n        // for the `eosToken`.\n        if (transformTokenFn && j < length) t = transformTokenFn(t, cache, param, j);\n\n        // Find next state on the basis of current `state` and current token – `t`.\n        ns = fsm[state][t] || root;\n        // Detect the state transition to capture `first` token of a potential upcoming\n        // pattern. If state is `root` and the next state is `non-root` indicates\n        // that we have just starting chasing for a new pattern.\n        if (!state && ns) first = j;\n        if (terminalStates[ns]) {\n          // Terminal state encountered, save this pattern. Update span using `delta`.\n          p = [first, j + delta - 1, ns];\n          pushMatch2Patterns(patterns, p);\n          // Set index to `j`, so that iterations can commence from `j + 1` as\n          // for-loop increments the index variable at the end of loop!\n          i = j;\n          // Ensures that the inner loop terminates!\n          j = length + 100;\n          // Pattern has been discovered, so next state must be set to `root`.\n          ns = root;\n          // Same is true for the last saved otherwise state.\n          lastOtherwiseState = root;\n        } else if (ns === root) {\n          // Not a terminal state but the next state has hit the `root`.\n          if (lastOtherwiseState) {\n            // But we have a `non-root` last saved otherwise state; this means\n            // we must save this pattern.\n            p = [first, lastOtherwiseIndex, lastOtherwiseState];\n            pushMatch2Patterns(patterns, p);\n            // Set index to the index corresponding to the above last saved otherwise\n            // state.\n            i = lastOtherwiseIndex;\n            // Ensure that the inner loop terminates;\n            j = length + 100;\n            // Pattern has been discovered, so next state must be set to `root`.\n            ns = root;\n            // Same is true for the last saved otherwise state.\n            lastOtherwiseState = root;\n          } else {\n            // The last saved otherwise state is pointing to `root`: terminate\n            // the inner loop without updating the index variable — this ensures\n            // complete roll back.\n            j = length + 100;\n          }\n        }\n        // Update the current state.\n        state = ns;\n        // Save (last) non-root otherwise state & index, if any.\n        if (fsm[state][otherwise]) {\n          // Update span using `delta`.\n          lastOtherwiseIndex = j + delta - 1;\n          lastOtherwiseState = fsm[state][otherwise];\n        }\n      }\n    }\n    return patterns;\n  }; // recognize()\n\n  // ## exportJSON\n  /**\n   * Exports the learning as a JSON, which may be saved as a text file for\n   * later use via `importJSON()`.\n   *\n   * @return {string} Learning in JSON format.\n   * @private\n  */\n  var exportJSON = function () {\n    return JSON.stringify([100, lastUsedState, fsm, terminalStates, markedStates, customPropertyAtStates]);\n  }; // exportJSON()\n\n  // ## emptyModelJSON\n  /**\n   * Exports the an empty model's JSON. Useful in model generation.\n   *\n   * @return {string} Learning in JSON format.\n   * @private\n  */\n  var emptyModelJSON = function () {\n    // Empty machine!\n    const m0 = Object.create(null);\n    m0[0] = Object.create(null);\n    return JSON.stringify([100, 0,\n    // `lastUsedState`.\n    m0,\n    // `fsm`,\n    Object.create(null),\n    // `terminalStates`,\n    Object.create(null),\n    // `markedStates`,\n    Object.create(null) // `customPropertyAtStates`\n    ]);\n  }; // emptyModelJSON()\n\n  // ## importJSON\n  /**\n   * Imports an existing JSON learning for recognition.\n   *\n   * @param {JSON} json containing learnings in as exported by `exportJSON()`.\n   * @return {void} Nothing!\n   * @throws Error if `json` is invalid.\n   * @private\n  */\n  var importJSON = function (json) {\n    var model = JSON.parse(json);\n    lastUsedState = model[1];\n    fsm = model[2];\n    terminalStates = model[3];\n    markedStates = model[4];\n    customPropertyAtStates = model[5];\n  }; // importJSON()\n\n  // Prints the model in terms of the state machine & terminal states.\n  var printModel = function () {\n    console.log('State Machine:');\n    console.log(JSON.stringify(fsm, null, 2));\n    console.log();\n    console.log('Terminal States:');\n    console.log(JSON.stringify(terminalStates, null, 2));\n    console.log();\n    console.log('Marked States:');\n    console.log(JSON.stringify(markedStates, null, 2));\n    console.log();\n    console.log('customProperty States:');\n    console.log(JSON.stringify(customPropertyAtStates, null, 2));\n  }; // printModel()\n\n  methods.learn = learn;\n  methods.recognize = recognize;\n  methods.setPatternSwap = setPatternSwap;\n  methods.setOnPatternDetectionFn = setOnPatternDetectionFn;\n  methods.exportJSON = exportJSON;\n  methods.importJSON = importJSON;\n  methods.emptyModelJSON = emptyModelJSON;\n  methods.printModel = printModel;\n\n  // This a dummy statement to ensure 100% coverage; because feature of\n  // collapsing shared states into single one was **disabled** due to `mark`.\n  getNextState(0, 0, 99);\n  return methods;\n}; // fsm()\n\nmodule.exports = simpleFSM;","map":{"version":3,"names":["composePatterns","require","identifyMarkedArea","eosTokenN","eosTokenX","otherwiseN","otherwiseX","simpleFSM","cache","token2Ignore","methods","Object","create","fsm","root","lastUsedState","terminalStates","markedStates","customPropertyAtStates","substitutions","onPatternDetectionFn","toBeIgnoredToken","undefined","keyLF","lookup","eosToken","otherwise","getNextState","index","last","target","learnSinglePattern","name","pattern","mark","customProperty","length","state","goBackTo","ev","nextState","k","learn","patterns","obj","cp","i","pi","all","j","push","sort","a","b","ts","keys","setOnPatternDetectionFn","f","pushMatch2Patterns","match","m0","setPatternSwap","Array","isArray","forEach","e","recognize","tokens","transformToken","param","transformTokenFn","first","ns","p","lastOtherwiseIndex","lastOtherwiseState","t","delta","exportJSON","JSON","stringify","emptyModelJSON","importJSON","json","model","parse","printModel","console","log","module","exports"],"sources":["C:/Users/cheko/Desktop/Education/Freelance/criticowl-main/criticowl_frontend/node_modules/wink-nlp/src/automaton.js"],"sourcesContent":["//     wink-nlp\n//\n//     Copyright (C) GRAYPE Systems Private Limited\n//\n//     This file is part of “wink-nlp”.\n//\n//     Permission is hereby granted, free of charge, to any\n//     person obtaining a copy of this software and\n//     associated documentation files (the \"Software\"), to\n//     deal in the Software without restriction, including\n//     without limitation the rights to use, copy, modify,\n//     merge, publish, distribute, sublicense, and/or sell\n//     copies of the Software, and to permit persons to\n//     whom the Software is furnished to do so, subject to\n//     the following conditions:\n//\n//     The above copyright notice and this permission notice\n//     shall be included in all copies or substantial\n//     portions of the Software.\n//\n//     THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF\n//     ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED\n//     TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A\n//     PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL\n//     THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,\n//     DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF\n//     CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN\n//     CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER\n//     DEALINGS IN THE SOFTWARE.\n\n//\n\n/* eslint-disable no-console */\n/* eslint-disable guard-for-in */\nconst composePatterns = require( './compose-patterns.js' );\nconst identifyMarkedArea = require( './identify-marked-area.js' );\n\nconst eosTokenN = 2070000;\nconst eosTokenX = '$%^EoS^%$';\nconst otherwiseN = 2070003;\nconst otherwiseX = ' otherwise';\n\nvar simpleFSM = function ( cache, token2Ignore ) {\n  // Returned!\n  var methods = Object.create( null );\n  // Holds FSM in the following structure:<br/>\n  // curr state —> event —> next state <br/>\n  // One of the event is `otherwise`, whose next state defines the default state.\n  var fsm = Object.create( null );\n  // The root or the beginning state of the `fsm`.\n  const root = 0;\n  // Tracks the last used state. Whenever a new state is needed, its value is\n  // incremented and returned. See `getNextState()`.\n  var lastUsedState =  0;\n  // The terminal states i.e. the detected patterns: maps state to name.\n  var terminalStates = Object.create( null );\n  // The terminal states, where part of pattern has been marked out.\n  var markedStates = Object.create( null );\n  // Add-ons value is stored here.\n  var customPropertyAtStates = Object.create( null );\n  // Use to substitute tokens by patterns in a multi-pass scenario.\n  var substitutions;\n  // On pattern detection function.\n  var onPatternDetectionFn;\n  // By default always ignore the new line character, else use the value supplied\n  // by `token2Ignore`; this will usually be the OOV lexeme, i.e. `$%^oov^%$`.\n  const toBeIgnoredToken =  ( token2Ignore === undefined ) ? '\\n' : token2Ignore;\n  // The `cache` is `undefined`, when things have to work on token text — for\n  // learning & recognition both. For native case of learning (i.e. generation),\n  // it can be `null` or real value; and native mode recognition will always\n  // need real value of the `cache`.\n  // Setup `keyLF/eosToken` to use during entity detection on the basis of `cache`\n  // value — It is critical for model generation.\n  const keyLF = ( cache === undefined || cache === null ) ? toBeIgnoredToken : cache.lookup( toBeIgnoredToken )[ 0 ];\n  const eosToken = ( cache === undefined || cache === null ) ? eosTokenX : eosTokenN;\n  // The `otherwise` event; including a space to ensure that such an input can\n  // never arrive from the token stream. Later on it will be changed to numeric\n  // value > `0xFFFFF` i.e. the limit of vocabulary.\n  const otherwise = ( cache === undefined ) ? otherwiseX : otherwiseN;\n\n  // ## getNextState\n  /**\n   *\n   * Returns the next state to be assigned i.e. the next unused state or\n   * a state corresponding to target, if defined.\n   *\n   * @param {number} index of current token.\n   * @param {number} last index of last token.\n   * @param {number} target state of the pattern being processed; could be\n   * `undefined` if it is being encountered for the first time.\n   * @returns {number} next state that should be assigned for the current event.\n   * @private\n  */\n  var getNextState = function ( index, last, target ) {\n    // Check its invocation in the of fsm.\n    if ( index === last && target ) return target;\n    // Compute next unused state & return. Note this now becomes the last\n    // used state!\n    lastUsedState += 1;\n    return lastUsedState;\n  }; // getNextState()\n\n  // ## learnSinglePattern\n  /**\n   *\n   * Learns a single pattern.\n   *\n   * @param {string} name of the pattern to be learned.\n   * @param {array} pattern to be learned.\n   * @param {array} mark `[ start, end ]`.\n   * @param {any} customProperty contains definable value(s).\n   * @returns {undefined} Nothing!\n   * @private\n  */\n  var learnSinglePattern = function ( name, pattern, mark, customProperty ) {\n    const length = pattern.length;\n    // Last element.\n    const last = length - 1;\n    // Target state for this pattern, would be `undefined` if this pattern type is\n    // enountered for the first time (`undefined` disables collapse of states).\n    const target = undefined;\n    // Tracks the `state` as the FSM builds up, specially useful if there are\n    // machines with shared path i.e. common `(state, events)` pairs.\n    let state = root;\n    // Assigned for `otherwise` events.\n    let goBackTo = root;\n    // Temp for event & next state.\n    let ev, nextState;\n\n    // Iterate through the pattern's tokens, while discovering any existing\n    // machine that can share path.\n    for ( let k = 0; k < length; k += 1 ) {\n      ev = pattern[ k ];\n      // Create new state & intialize, if required.\n      if ( fsm[ state ] === undefined ) {\n        fsm[ state ] = Object.create( null );\n        fsm[ state ][ otherwise ] = goBackTo;\n      }\n      // Check for machines that may share path.\n      if ( fsm[ state ][ ev ] === undefined ) {\n        // None found, create new state transition by assigning the next state for\n        // the current event – `ev`.\n        nextState = getNextState( k, last, target );\n        fsm[ state ][ ev ] = nextState;\n        // Always compute state transition from the perspective of discovering\n        // shared path: here the `fsm[ state ][ ev ]` has been just assigned\n        // `nextState`, therefore `state` needs to transition to this state only.\n        state = nextState;\n      } else if ( terminalStates[ fsm[ state ][ ev ] ] ) {\n          // Case when shared path is found and the next state on the path is a\n          // terminal state.\n          if ( fsm[ state ][ otherwise ] === root ) fsm[ state ][ otherwise ] = goBackTo;\n          goBackTo = fsm[ state ][ ev ];\n          nextState = getNextState( k, last, target );\n          fsm[ state ][ ev ] = nextState;\n          // Compute state transition; again like earlier case, it would be `nextState`.\n          state = nextState;\n        } else if ( k === last ) {\n            // Case when shared path is found and the next state on the path is NOT\n            // a terminal state AND current token is the LAST one.\n            nextState = getNextState( k, last, target );\n            fsm[ fsm[ state ][ ev ] ][ otherwise ] = nextState;\n            state = nextState;\n          } else {\n            // Case when shared path is found and the next state on the path is NOT\n            // a terminal state AND current token is NOT the LAST one.<br/>\n            // Simply compute state transition, no other work to be done!\n            state = fsm[ state ][ ev ];\n          }\n    }\n    terminalStates[ state ] = name;\n\n    if ( mark ) {\n      // Update last element of `mark` to simplifies computations during fsm\n      // execution. Update must happen as a deep copy & not directly!\n      markedStates[ state ] = identifyMarkedArea( mark, length );\n    }\n\n    if ( customProperty !== undefined ) {\n      customPropertyAtStates[ state ] = customProperty;\n    }\n  }; // learnSinglePattern()\n\n  // ## learn\n  /**\n   *\n   * Learns the patterns that must be detected via recognize() API calls.\n   *\n   * @param {Object[]} patterns to be learned.\n   *\n   * @param {string} patterns[].name of the pattern.\n   * @param {string} patterns[].structure of the pattern.\n   * @returns {number} of uniquely named patterns.\n   * `[ pattern-id, start-token, end-token ]` format.\n   * @private\n  */\n  var learn = function ( patterns ) {\n    // Temp for counting unique.\n    var obj = Object.create( null );\n    // Composed Patterns\n    var cp = [];\n    for ( let i = 0; i < patterns.length; i += 1 ) {\n      const pi = patterns[ i ];\n      if ( typeof pi.pattern === 'string' ) {\n        const all = composePatterns( pi.pattern );\n        for ( let j = 0; j < all.length; j += 1 )\n          cp.push( { name: pi.name, pattern: all[ j ], mark: pi.mark, customProperty: pi.customProperty } );\n      } else cp.push( { name: pi.name, pattern: pi.pattern, mark: pi.mark, customProperty: pi.customProperty } );\n    }\n    // Sort to get the longest pattern on the top.\n    cp.sort( ( a, b ) => ( b.pattern.length - a.pattern.length ) );\n    // All set, now learn using composed patterns – `cp`!\n    for ( let i = 0; i < cp.length; i += 1 ) {\n      learnSinglePattern( cp[ i ].name, cp[ i ].pattern, cp[ i ].mark, cp[ i ].customProperty );\n    }\n    // Return number of uniquely named patterns.\n    for ( const ts in terminalStates ) obj[ terminalStates[ ts ] ] = true;\n    return ( ( Object.keys( obj ) ).length );\n  }; // learn()\n\n  // ## setOnPatternDetectionFn\n  /**\n   *\n   * Defines the function that is called on every detected pattern, provided\n   * the detected pattern had an `customProperty` property defined.\n   * @param {function} f to be called with `match` & `customProperty` value as parameters.\n   * @returns {boolean} `true` if it was a success otherwise `false`.\n   * @private\n  */\n  var setOnPatternDetectionFn = function ( f ) {\n    if ( typeof f === 'function' ) {\n      onPatternDetectionFn = f;\n      return true;\n    }\n    return false;\n  }; // setOnPatternDetectionFn()\n\n  // ## pushMatch2Patterns\n  /**\n   *\n   * Pushes a `match`ed pattern details into the `patterns` array after handling\n   * marking and calling the on pattern detection function, if required. Before\n   * pushing a `match` to patterns, the state (numeric) at `match[ 2 ]` is mapped\n   * to its name using `terminalStates`; remember the `state` passed here is\n   * always the terminal state. Passing state in match ensures that respective\n   * `mark` and `customProperty` are handled differently if they have different values in\n   * a state-machine rows, even though the `names` are identical.\n   *\n   * @param {array} patterns where the `match` is pushed.\n   * @param {array} match pushed in to the `patterns`. The `match` conntains\n   * 3-entries viz. 0—state, 1 & 2—start & end indexes of `tokens`.\n   * @returns {undefined} Nothing.\n   * @private\n  */\n  var pushMatch2Patterns = function ( patterns, match ) {\n    // Extract the state at match[ 0 ].\n    var m0 = match[ 2 ];\n    // Pattern name `'0'` — simply ignore it!\n    if ( terminalStates[ m0 ] === '0' ) return;\n    // Not to be ignored — process it.\n    var mark = markedStates[ m0 ];\n    var customProperty = customPropertyAtStates[ m0 ];\n    if ( mark ) {\n      match[ 0 ] += mark[ 0 ];\n      match[ 1 ] -= mark[ 1 ];\n    }\n\n    // Removed `customProperty !== undefined &&` check while coding pos experiment\n    if ( onPatternDetectionFn )\n      onPatternDetectionFn( match, customProperty );\n\n    match[ 2 ] = terminalStates[ m0 ];\n\n    patterns.push( match );\n  }; // pushPattern()\n\n  // ## setPatternSwap\n  /**\n   *\n   * Sets up the patterns to be used for token substitution/swap in the\n   * `recognize()` api.\n   *\n   * @param {array[]} patterns to be used for substitutions in `recognize()`.\n   * @returns {undefined} Nothing.\n   * @private\n  */\n  var setPatternSwap = function ( patterns ) {\n    if ( !patterns || !Array.isArray( patterns ) ) {\n      substitutions = undefined;\n      return;\n    }\n    // Old `substitutions` are re-initialized.\n    substitutions = Object.create( null );\n    // Sort patterns by the start of pattern index.\n    patterns.sort( ( a, b ) => ( a[ 0 ] > b[ 0 ] ) );\n    // Index it by start of pattern.\n    patterns.forEach( ( e ) => ( substitutions[ e[ 0 ] ] = [ e[ 1 ], e[ 2 ] ] ) );\n  }; // setPatternSwap()\n\n  // ## recognize\n  /**\n   *\n   * Recognizes patterns present in the input tokens in a greedy manner.\n   *\n   * @param {array} tokens in which the patterns need to be recognized.\n   * @param {function} [transformToken] an optional function that is called before\n   * processing every token.\n   * @param {*} [param] that has to be passed as the last param to `transformToken()`\n   * function.\n   * @returns {array[]} where each element follows\n   * `[ pattern-id, start-token, end-token ]` format.\n   * @private\n  */\n  var recognize = function ( tokens, transformToken, param ) {\n    // Length of the `tokens.`\n    const length = tokens.length;\n    // Check if `transformToken` is a valid function.\n    var transformTokenFn = ( typeof transformToken === 'function' ) ? transformToken : null;\n    // Detected patterns are captured here. Each element has the following format: <br/>\n    // `[ pattern-id, start-token, end-token ]`\n    var patterns = [];\n    // We don't need a separate state machines unlike `recognize()`, as the\n    // following set of variables together act like a singleton machine.\n    var first = 0;\n    var state = root;\n    // Next State.\n    var ns = root;\n    // Temp. for a single pattern.\n    var p = null;\n    // Last non-root otherwise state & index\n    var lastOtherwiseIndex;\n    var lastOtherwiseState;\n    // Temp. for a token.\n    var t;\n    // Used to increment `j` and computing span of pattern correctly, may become\n    // > 1 if an earlier detected pattern is longer that 1-token.\n    var delta = 1;\n\n    for ( let i = 0; i <= length; i += 1 ) {\n      // **Attempt greedy lookup**:<br/>\n      // Keep digging until next state becomes `root` or a terminal state is\n      // encountered. Upon failure after a partial match, roll back is required\n      // so that the extra consumed tokens can be explored by machine.\n      for ( let j = i; j <= length; j += delta ) {\n        // Extract current token.\n        t = ( j === length ) ?  eosToken : tokens[ j ];\n\n        // Skip the newline character; TODO: will replace by the hash value!\n        // Use direct hash for the time being later, it must be obtained via cache\n        if ( t === keyLF ) continue; // eslint-disable-line no-continue\n\n        // Perform replacements using earlier detected patterns.\n        if ( substitutions && substitutions[ j ] ) {\n          t = substitutions[ j ][ 1 ];\n          delta = substitutions[ j ][ 0 ] - j + 1;\n        } else delta = 1;\n\n        // Apply token transformation function, if defined. Must not be called\n        // for the `eosToken`.\n        if ( transformTokenFn && ( j < length ) ) t = transformTokenFn( t, cache, param, j );\n\n        // Find next state on the basis of current `state` and current token – `t`.\n        ns = fsm[ state ][ t ] || root;\n        // Detect the state transition to capture `first` token of a potential upcoming\n        // pattern. If state is `root` and the next state is `non-root` indicates\n        // that we have just starting chasing for a new pattern.\n        if ( !state && ns ) first = j;\n\n        if ( terminalStates[ ns ] ) {\n          // Terminal state encountered, save this pattern. Update span using `delta`.\n          p = [ first, j + delta - 1, ns ];\n          pushMatch2Patterns( patterns, p );\n          // Set index to `j`, so that iterations can commence from `j + 1` as\n          // for-loop increments the index variable at the end of loop!\n          i = j;\n          // Ensures that the inner loop terminates!\n          j = length + 100;\n          // Pattern has been discovered, so next state must be set to `root`.\n          ns = root;\n          // Same is true for the last saved otherwise state.\n          lastOtherwiseState = root;\n        } else if ( ns === root ) {\n          // Not a terminal state but the next state has hit the `root`.\n          if ( lastOtherwiseState ) {\n            // But we have a `non-root` last saved otherwise state; this means\n            // we must save this pattern.\n            p = [ first, lastOtherwiseIndex, lastOtherwiseState ];\n            pushMatch2Patterns( patterns, p );\n            // Set index to the index corresponding to the above last saved otherwise\n            // state.\n            i = lastOtherwiseIndex;\n            // Ensure that the inner loop terminates;\n            j = length + 100;\n            // Pattern has been discovered, so next state must be set to `root`.\n            ns = root;\n            // Same is true for the last saved otherwise state.\n            lastOtherwiseState = root;\n          } else {\n            // The last saved otherwise state is pointing to `root`: terminate\n            // the inner loop without updating the index variable — this ensures\n            // complete roll back.\n            j = length + 100;\n          }\n        }\n        // Update the current state.\n        state = ns;\n        // Save (last) non-root otherwise state & index, if any.\n        if ( fsm[ state ][ otherwise ] ) {\n          // Update span using `delta`.\n          lastOtherwiseIndex = j + delta - 1;\n          lastOtherwiseState = fsm[ state ][ otherwise ];\n        }\n      }\n    }\n\n    return patterns;\n  }; // recognize()\n\n  // ## exportJSON\n  /**\n   * Exports the learning as a JSON, which may be saved as a text file for\n   * later use via `importJSON()`.\n   *\n   * @return {string} Learning in JSON format.\n   * @private\n  */\n  var exportJSON = function () {\n    return JSON.stringify(\n      [ 100, lastUsedState, fsm, terminalStates, markedStates, customPropertyAtStates ]\n    );\n  }; // exportJSON()\n\n  // ## emptyModelJSON\n  /**\n   * Exports the an empty model's JSON. Useful in model generation.\n   *\n   * @return {string} Learning in JSON format.\n   * @private\n  */\n  var emptyModelJSON = function () {\n    // Empty machine!\n    const m0 = Object.create( null );\n    m0[ 0 ] = Object.create( null );\n    return JSON.stringify(\n      [ 100,\n        0,                      // `lastUsedState`.\n        m0,                     // `fsm`,\n        Object.create( null ),  // `terminalStates`,\n        Object.create( null ),  // `markedStates`,\n        Object.create( null ),  // `customPropertyAtStates`\n      ]\n    );\n  }; // emptyModelJSON()\n\n  // ## importJSON\n  /**\n   * Imports an existing JSON learning for recognition.\n   *\n   * @param {JSON} json containing learnings in as exported by `exportJSON()`.\n   * @return {void} Nothing!\n   * @throws Error if `json` is invalid.\n   * @private\n  */\n  var importJSON = function ( json ) {\n    var model =  JSON.parse( json );\n    lastUsedState = model[ 1 ];\n    fsm = model[ 2 ];\n    terminalStates = model[ 3 ];\n    markedStates = model[ 4 ];\n    customPropertyAtStates = model[ 5 ];\n  }; // importJSON()\n\n  // Prints the model in terms of the state machine & terminal states.\n  var printModel = function () {\n    console.log( 'State Machine:' );\n    console.log( JSON.stringify( fsm, null, 2 ) );\n    console.log();\n    console.log( 'Terminal States:' );\n    console.log( JSON.stringify( terminalStates, null, 2 ) );\n    console.log();\n    console.log( 'Marked States:' );\n    console.log( JSON.stringify( markedStates, null, 2 ) );\n    console.log();\n    console.log( 'customProperty States:' );\n    console.log( JSON.stringify( customPropertyAtStates, null, 2 ) );\n  }; // printModel()\n\n\n  methods.learn = learn;\n  methods.recognize = recognize;\n  methods.setPatternSwap = setPatternSwap;\n  methods.setOnPatternDetectionFn = setOnPatternDetectionFn;\n  methods.exportJSON = exportJSON;\n  methods.importJSON = importJSON;\n  methods.emptyModelJSON = emptyModelJSON;\n\n  methods.printModel = printModel;\n\n  // This a dummy statement to ensure 100% coverage; because feature of\n  // collapsing shared states into single one was **disabled** due to `mark`.\n  getNextState( 0, 0, 99 );\n  return methods;\n}; // fsm()\n\nmodule.exports = simpleFSM;\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"script","externalDependencies":[]}