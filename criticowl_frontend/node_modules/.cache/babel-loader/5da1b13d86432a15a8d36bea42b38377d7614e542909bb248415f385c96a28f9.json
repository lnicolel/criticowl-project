{"ast":null,"code":"//     wink-nlp\n//\n//     Copyright (C) GRAYPE Systems Private Limited\n//\n//     This file is part of “wink-nlp”.\n//\n//     Permission is hereby granted, free of charge, to any\n//     person obtaining a copy of this software and\n//     associated documentation files (the \"Software\"), to\n//     deal in the Software without restriction, including\n//     without limitation the rights to use, copy, modify,\n//     merge, publish, distribute, sublicense, and/or sell\n//     copies of the Software, and to permit persons to\n//     whom the Software is furnished to do so, subject to\n//     the following conditions:\n//\n//     The above copyright notice and this permission notice\n//     shall be included in all copies or substantial\n//     portions of the Software.\n//\n//     THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF\n//     ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED\n//     TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A\n//     PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL\n//     THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,\n//     DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF\n//     CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN\n//     CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER\n//     DEALINGS IN THE SOFTWARE.\n\n//\n\nvar constants = require('./constants.js');\nvar xnMask = constants.xnMask;\nvar bits4PrecedingSpace = constants.bits4PrecedingSpace;\nvar xcMask = constants.xcMask;\nvar bits4xpPointer = constants.bits4xpPointer;\n\n// ## cache\n/**\n *\n * Creates an instance of `cache`. It is typically instantiated in each `winkNLP`\n * instance and there it is responsible for caching token properties acrosss the\n * documents i.e. the `doc()`.\n *\n * @param {Array} model containing language model.\n * @param {Array} featureFn extracts language specific features of a lexeme.\n * @return {object} of methods.\n * @private\n*/\nvar cache = function (model, featureFn) {\n  const fTokenType = 'tokenType';\n  // Returned!\n  var methods = Object.create(null);\n  // Extract frequently used properties.\n  var lexemesHash = model.features.lexeme.hash;\n  var lxm = model.features.lexeme;\n  var lexemeIntrinsicSize = model.features.lexeme.intrinsicSize;\n  var layout = model.packing.layout;\n  var pkSize = model.packing.size;\n  var efSize = model.packing.efSize;\n  var efList = model.packing.efList;\n  var efListSize = efList.length;\n  var lexicon = model.lexicon;\n  var xpansions = model.xpansions;\n  var posClusters = model.features.posClusters.list;\n  // Contains quantas of UInt32Array of size `model.packing.size`. A quanta\n  // at an `index` contains the features of the corresponding OOV lexeme loacted\n  // at `model.features.lexeme.list[ index ]`. This simplifies information access,\n  // as it remains identical to the **intrinsic lexicon** with the only difference\n  // that this not a continuous array of UInt32s. It follows\n  // `[ normal, lemma, <extractable features> ]` structure. The extractable\n  // features will be dynamically determined using the language model.\n  var extrinsicLexicon = [];\n  // Base Packing Size is `2` because one word each for normal & lemma is needed.\n  var elBasePackingSize = 2;\n  // Packing size for each lexeme in `extrinsicLexicon` — base plus additional\n  // words needed for extractable features.\n  var elPackingSize = 2 + efSize;\n  // Extractable Features temp storage; eventually its contents will be pushed\n  // inside `extrinsicLexicon`. Space is allocated right in the beginning to save\n  // time. Its contents are filled i.e. initialized with 0 whenever needed.\n  var efArray = new Uint32Array(efSize);\n  var feature = featureFn(model.packing.config);\n\n  // Extractable Features Hash: used during property extraction for OOV tokens.\n  // If a token is not found in this then a **0** is returned.\n  var efHash = Object.create(null);\n  // Since `tokenType` is determined during tokenization, it is always extractable.\n  efHash.tokenType = true;\n  // Copy rest from the list in to the hash.\n  efList.forEach(ef => efHash[ef] = true);\n\n  // ## getFeaturesIndex\n  /**\n   *\n   * Returns the `index` of `value` from the feature `name`. If the value is\n   * missing then it is added and its `index` is returned accordingly alongwith\n   * a flag indicating that it is a new value.\n   *\n   * @param {string} name of the feature.\n   * @param {string} value of the feature, whoes index will be returned.\n   * @return {number[]} `[ isNewValue, index ]`.\n   * @example\n   * // Returns the index (hash) of **lexeme** – `you`:\n   * getFeaturesIndex( 'lexeme', 'you' );\n   * // -> [ 0, 47 ]\n   * // If `you` was absent then it would have been added and the return value\n   * // would have been [ 1, index of added value ]\n   * @private\n  */\n  var getFeaturesIndex = function (name, value) {\n    // Extract the named feature.\n    var f = model.features[name];\n    // And its hash & list.\n    var h = f.hash;\n    var l = f.list;\n    // New `value` flag.\n    var isNewValue = 0;\n    // Check if `value` is present.\n    var index = h[value];\n    if (index === undefined) {\n      // Feature's storage limit check. — not required right now!\n      // if ( f.index > f.maxIndex ) {\n      //   throw Error( `wink-nlp: memory limit for \"${name}\" exceeded.` );\n      // }\n      // Missing — add `value`.\n      index = h[value] = f.index;\n      // No need to increment index because push returns the required value!\n      f.index = l.push(value);\n      // Set new value flag.\n      isNewValue = 1;\n    }\n    return [isNewValue, index];\n  }; // getFeaturesIndex()\n\n  // ## add\n  /**\n   *\n   * Adds a token in the cache corresponding to the **text**. If the same is\n   * present in the cache then a pointer to its cached value is retured; otherwise\n   * a new entry is made in the cache and the same is returned.\n   *\n   * Whenever a new entry is made, all its extractable features are also\n   * extracted & packed; and if an extractable feature is also new, its entry\n   * is also made via `getFeaturesIndex()` api.\n   *\n   * @param {string} text i.e. the value of the token to be added.\n   * @param {number} category of the token i.e. `word(0)` or `number(1)`, etc.\n   * @return {number[]} index (or hash) of the `text` added.\n   * @private\n  */\n  var add = function (text, category) {\n    // Lowercased `text`.\n    var normText = text.toLowerCase();\n    // First start with `text` as its properties are being processed first.\n    var textIndex = getFeaturesIndex('lexeme', text);\n    // Then obtain index of its normal.\n    var normIndex = normText === text ? textIndex : getFeaturesIndex('lexeme', normText);\n    // Helpers: cfg of feature, feature, feature's value, feature's value for\n    // packing & loop index.\n    var cfg, f, fv, fv4p, k;\n\n    // Process properties of `text` first.\n    // The `textIndex[ 0 ]` is a indicated if the value is newly added, and if\n    // so then add extract-able features. See `getFeaturesIndex()` above.\n    if (textIndex[0]) {\n      // NOTE: This block of code is repeated below, with an exception that\n      // in the next block we use `normtext` in `fv = feature[ f ]( text )`.\n      // Intialize extractable featires' array with all 0s.\n      efArray.fill(0);\n      // For every extractable feature, extract & pack.\n      for (k = 0; k < efListSize; k += 1) {\n        f = efList[k];\n        cfg = layout[f];\n        // Use `text`.\n        fv = feature[f](text, category, methods);\n        fv4p = cfg[3] ? fv : getFeaturesIndex(f, fv)[1];\n        efArray[cfg[0]] |= fv4p << cfg[2]; // eslint-disable-line no-bitwise\n      } // for\n      // Pack token type now.\n      f = fTokenType;\n      cfg = layout[f];\n      efArray[cfg[0]] |= category << cfg[2]; // eslint-disable-line no-bitwise\n      // Push all the details i.e. `[ normal, lemma, <extractable features> ]`\n      // into `extrinsicLexicon`.\n      extrinsicLexicon.push(normIndex[1], normIndex[1], ...efArray);\n    } // if ( >= lexemeIntrinsicSize )\n\n    // If the normalized text is not same as the original text then the\n    // normalize text's extract-able features could be candidates for addition.\n    if (textIndex[1] !== normIndex[1]) {\n      // Has it been newly added? If Yes, add its extract-able features.\n      if (normIndex[0]) {\n        // NOTE: This block of code is same as above.\n        // Intialize extractable featires' array with all 0s.\n        efArray.fill(0);\n        // For every extractable feature, extract & pack.\n        for (k = 0; k < efListSize; k += 1) {\n          f = efList[k];\n          cfg = layout[f];\n          // Use `normText`.\n          fv = feature[f](normText, category, methods);\n          fv4p = cfg[3] ? fv : getFeaturesIndex(f, fv)[1];\n          efArray[cfg[0]] |= fv4p << cfg[2]; // eslint-disable-line no-bitwise\n        } // for\n        // Pack token type now.\n        f = fTokenType;\n        cfg = layout[f];\n        efArray[cfg[0]] |= category << cfg[2]; // eslint-disable-line no-bitwise\n        // Push all the details i.e. `[ normal, lemma, <extractable features> ]`\n        // into `extrinsicLexicon`.\n        extrinsicLexicon.push(normIndex[1], normIndex[1], ...efArray);\n      } // if ( >= lexemeIntrinsicSize )\n    } // if ( textIndex !== normIndex )\n\n    // Return the `textIndex` only – this can be sued to extract properties.\n    return textIndex[1];\n  }; // add()\n\n  // ## lookup\n  /**\n   *\n   * Looks up for the `text` in the cache and returns its index. If the input\n   * text is a contraction then its expansions are returned.\n   *\n   * @param {string} text to be searched in the cache.\n   * @return {number[]} contains either a single element (i.e. `index`) indicating\n   * that it is NOT a contraction or multiple elements indication that the text\n   * is a contraction. Each contraction expands into 4 elements viz. `lexeme`,\n   * `normal`, `lemma` , and `pos`.\n   * @private\n  */\n  var lookup = function (text) {\n    // `layout.isContraction` for multiple use later.\n    var layout4isContraction = layout.isContraction;\n    var layout4lemma = layout.lemma;\n    // `index` to `text`.\n    var index = lexemesHash[text];\n    // Holds lemma extracted in case of contraction.\n    var lemma;\n    // Contraction Count, Contraction Index, Loop Index.\n    var cc, cx, cxi;\n\n    // If the text is not found, return `null`.\n    if (index === undefined) return null;\n    // `text` is found – need to check for contraction if `text` is not an OOV.\n    var tokens = [];\n    var isContraction;\n    if (index < lexemeIntrinsicSize) {\n      // Not an OOV, check it it is a contraction.\n      isContraction = (lexicon[layout4isContraction[0] + index * pkSize] & layout4isContraction[1]) >>> layout4isContraction[2]; // eslint-disable-line no-bitwise\n      if (isContraction) {\n        // It is a contraction, process its expansions.\n        // Start by extracting lemma, as it contains pointer to `expansions` and their count.\n        lemma = (lexicon[layout4lemma[0] + index * pkSize] & layout4lemma[1]) >>> layout4lemma[2]; // eslint-disable-line no-bitwise\n        // Extract pointer (i.e. index) to expansions and their count.\n        cx = lemma & 0x3FFF; // eslint-disable-line no-bitwise\n        cc = (lemma & xcMask << bits4xpPointer) >> bits4xpPointer; // eslint-disable-line no-bitwise\n        // Iterate through `cc` times to push details into the `tokens`.\n        for (cxi = 0; cxi < cc; cxi += 4) {\n          tokens.push(xpansions[cx + cxi],\n          // lexeme\n          cx + cxi + 1,\n          // normal (pointer to xpansion & not to lexicon)\n          xpansions[cx + cxi + 2],\n          // lemma\n          xpansions[cx + cxi + 3] // pos\n          );\n        }\n      } else {\n        // Not a contraction, simply add `text`'s `index` to `tokens`.\n        tokens.push(index);\n      }\n    } else {\n      // An OOV, only add `text`'s `index` to `tokens`.\n      tokens.push(index);\n    }\n    return tokens;\n  }; // lookup()\n\n  // ## value\n  /**\n   *\n   * Returns the value corresponding to the `index`.\n   *\n   * @param {number} index for the value.\n   * @return {string} value corresponding to the `index`.\n   * @private\n  */\n  var value = function (index) {\n    return lxm.list[index];\n  }; // value()\n\n  // ## normal\n  /**\n   *\n   * Returns the index of normal of the input `index` (of required lexeme) after\n   * taking into account mapping of spelling, if any.\n   *\n   * @param {number} index of the required lexeme.\n   * @return {string} index to the normal.\n   * @private\n  */\n  var normal = function (index) {\n    // Temps for `layput.normal`, `layout.isSpellingMapped`, etc.\n    var layout4normal = layout.normal;\n    var layout4mapped = layout.isSpellingMapped;\n    var layout4lemma = layout.lemma;\n    // Used to remap if its value is `1`. In this case lemma becomes the `normIndex`.\n    var isSpellingMapped;\n    // Index for OOVs i.e. when `index > lexemeIntrinsicSize`.\n    var oovIdx;\n    // Returned: normal's index.\n    var normIndex;\n\n    // Processing is different for native and OOV words or lexemes. For OOVs\n    // properties have to be extracted from `extrinsicLexicon`, whereas for\n    // native words they are exracted from `lexicon`.\n    if (index < lexemeIntrinsicSize) {\n      normIndex = (lexicon[layout4normal[0] + index * pkSize] & layout4normal[1]) >>> layout4normal[2]; // eslint-disable-line no-bitwise\n      isSpellingMapped = (lexicon[layout4mapped[0] + index * pkSize] & layout4mapped[1]) >>> layout4mapped[2]; // eslint-disable-line no-bitwise\n      if (isSpellingMapped) {\n        // Mapped, pick up the lemma portion as this points to normal in case of\n        // mapped spellings.\n        normIndex = (lexicon[layout4lemma[0] + index * pkSize] & layout4lemma[1]) >>> layout4lemma[2]; // eslint-disable-line no-bitwise\n      } else {\n        // Compute actual index from the relative index.\n        normIndex += index;\n      }\n    } else {\n      oovIdx = index - lexemeIntrinsicSize;\n      // Refer to `extrinsicLexicon` structure at the top of `cache()`.\n      normIndex = extrinsicLexicon[oovIdx * elPackingSize];\n      // This `normIndex` may point to an intrinsic lexeme, in which case\n      // mapping needs to be checked.\n      if (normIndex < lexemeIntrinsicSize) {\n        isSpellingMapped = (lexicon[layout4mapped[0] + normIndex * pkSize] & layout4mapped[1]) >>> layout4mapped[2]; // eslint-disable-line no-bitwise\n        if (isSpellingMapped) {\n          normIndex = (lexicon[layout4lemma[0] + normIndex * pkSize] & layout4lemma[1]) >>> layout4lemma[2]; // eslint-disable-line no-bitwise\n        }\n      }\n    }\n    return normIndex;\n  }; // normal()\n\n  // ## mappedSpelling\n  /**\n   *\n   * Returns the index of mapped spelling's of the input `index` of required lexeme.\n   *\n   * @param {number} index of the required lexeme.\n   * @return {string} index to the normal.\n   * @private\n  */\n  var mappedSpelling = function (index) {\n    // Temps for `layout.isSpellingMapped`, etc.\n    var layout4mapped = layout.isSpellingMapped;\n    var layout4lemma = layout.lemma;\n    // Used to remap if its value is `1`. In this case lemma becomes the `normIndex`.\n    var isSpellingMapped;\n    // Returned: normal's index.\n    var mappedIndex = index;\n\n    // Only applicable to lexems that are inside the vocabulary as there can not\n    // be mapped spelling for OOV words!\n    if (index < lexemeIntrinsicSize) {\n      isSpellingMapped = (lexicon[layout4mapped[0] + index * pkSize] & layout4mapped[1]) >>> layout4mapped[2]; // eslint-disable-line no-bitwise\n      if (isSpellingMapped) {\n        // Mapped, pick up the lemma portion as this points to normal in case of\n        // mapped spellings.\n        mappedIndex = (lexicon[layout4lemma[0] + index * pkSize] & layout4lemma[1]) >>> layout4lemma[2]; // eslint-disable-line no-bitwise\n      }\n    }\n    return mappedIndex;\n  }; // mappedSpelling()\n\n  // ## nox\n  /**\n   *\n   * Returns the index of normal of the expansion.\n   *\n   * @param {number} binaryWord containing pointer to `xpansions` and `precedingSpaces`;\n   * It is the 2nd (relative) element of a single token's packet of 4-words.\n   * @return {number} index to the normal, whoes value can be found via `value()`.\n   * @private\n  */\n  var nox = function (binaryWord) {\n    return xpansions[(binaryWord & xnMask) >>> bits4PrecedingSpace]; // eslint-disable-line no-bitwise\n  }; // nox()\n\n  // ## property\n  /**\n   *\n   * Extracts the property – `prop` of a lexeme (or word) specified by `index`.\n   *\n   * @param {number} index of the lexeme whoes properties are required to be extracted.\n   * @param {string} prop (name) that needs to be extracted — it should be a valid property.\n   * @return {string} extracted property, if `prop` is known/valid otherwise `null`.\n   * @private\n  */\n  var property = function (index, prop) {\n    // A property and its value\n    var propValue;\n    // Index for OOVs i.e. when `index > lexemeIntrinsicSize`.\n    var oovIdx;\n    // Temp for `layput[ p ]`\n    var layout4Prop;\n\n    // Processing is different for native and OOV words or lexemes. For OOVs\n    // properties have to be extracted from `extrinsicLexicon`, whereas for\n    // native words they are exracted from `lexicon`.\n    if (index < lexemeIntrinsicSize) {\n      layout4Prop = layout[prop];\n      if (layout4Prop === undefined) return null;\n      propValue = (lexicon[layout4Prop[0] + index * pkSize] & layout4Prop[1]) >>> layout4Prop[2]; // eslint-disable-line no-bitwise\n      // Use hash/list to update value if required.\n      if (layout4Prop[3] === 0 || layout4Prop[5] === 1) propValue = model.features[prop].list[propValue];\n    } else {\n      // Attempt extraction only if extractable!\n      if (!efHash[prop]) return 0;\n      // Compute index into `extrinsicLexicon`.\n      oovIdx = index - lexemeIntrinsicSize;\n      layout4Prop = layout[prop];\n      // No need for this check as `if ( !efHash[ prop ] )...` ensures return\n      // in case of any unknown property:\n      /* if ( layout4Prop  === undefined ) return null; */\n      // Use `extrinsicLexicon`.\n\n      // Reach to the desired quanta via `oovIdx * elPackingSize`, move forward by `base size` and then go to offset!\n      propValue = (extrinsicLexicon[oovIdx * elPackingSize + elBasePackingSize + layout4Prop[0]] & layout4Prop[1]) >>> layout4Prop[2]; // eslint-disable-line no-bitwise\n      // Use hash/list to update value if required.\n      if (layout4Prop[3] === 0 || layout4Prop[5] === 1) propValue = model.features[prop].list[propValue];\n    }\n    return propValue;\n  }; // property()\n\n  var isMemberPOS = function (lexemeIdx, posIdx) {\n    // Dont miss converting posIdx to a number.\n    return posClusters[property(lexemeIdx, 'lexemeCID')].has(+posIdx);\n  }; // isMemberPOS()\n\n  // ## posOf\n  /**\n   *\n   * Extracts the pos' index of the a lexeme (or word) specified by `index`.\n   *\n   * @param {number} index of the lexeme whoes properties are required to be extracted.\n   * @return {string[]} extracted properties in the same sequence as `list`.\n   * @private\n  */\n  var posOf = function (index) {\n    // Value of extracted pos will go here.\n    var posValue;\n    // Index for OOVs i.e. when `index > lexemeIntrinsicSize`.\n    var oovIdx;\n    // Temp for `layput[ p ]`\n    var layout4Prop;\n\n    // Processing is different for native and OOV words or lexemes. For OOVs\n    // properties have to be extracted from `extrinsicLexicon`, whereas for\n    // native words they are exracted from `lexicon`.\n    if (index < lexemeIntrinsicSize) {\n      layout4Prop = layout.pos;\n      posValue = (lexicon[layout4Prop[0] + index * pkSize] & layout4Prop[1]) >>> layout4Prop[2]; // eslint-disable-line no-bitwise\n    } else {\n      // Compute index into `extrinsicLexicon`.\n      oovIdx = index - lexemeIntrinsicSize;\n      layout4Prop = layout.pos;\n\n      // Use `extrinsicLexicon`.\n      // Reach to the desired quanta via `oovIdx * elPackingSize`, move forward by `base size` and then go to offset!\n      posValue = (extrinsicLexicon[oovIdx * elPackingSize + elBasePackingSize + layout4Prop[0]] & layout4Prop[1]) >>> layout4Prop[2]; // eslint-disable-line no-bitwise\n    }\n    return posValue;\n  }; // posOf()\n\n  // ## valueOf\n  /**\n   *\n   * Extracts the value of the `prop`erty for its input `index`.\n   *\n   * @param {string} prop to be extracted for the `index`.\n   * @param {number} index of the property.\n   * @return {string[]} extracted properties in the same sequence as `list`.\n   * @private\n  */\n  var valueOf = function (prop, index) {\n    return model.features[prop].list[index];\n  }; // valueOf()\n\n  // ## currentSize\n  /**\n   *\n   * Returns the current size of lexicon including OOVs.\n   *\n   * @return {number} size of the current lexicon.\n   * @private\n  */\n  var currentSize = function () {\n    // Minus `1` becuase at `0` we have OOV symbolic word.\n    return lxm.list.length - 1;\n  }; // size()\n\n  // ## intrinsicSize\n  /**\n   *\n   * Returns the intrinsic i.e. native size of lexicon.\n   *\n   * @return {number} size of the native or intrinsic lexicon.\n   * @private\n  */\n  var intrinsicSize = function () {\n    return lexemeIntrinsicSize;\n  };\n\n  /**\n   * Finds if the text can have `pos` as valid part of speech, provided it is a\n   * base form. Used in **lemmatization** to see if the lemma shares the same pos\n   * with the original word.\n   *\n   * @param  {string} text  the incoming word.\n   * @param  {string} pos   the pos that needs to be checked as one of the valid pos for text.\n   * @return {boolean}       True if it does, otherwise false.\n   */\n  var hasSamePOS = function (text, pos) {\n    // Get the word's index\n    var textIndex = lookup(text);\n    // If not found i.e. OOV means that it did not have a pre-defined POS set.\n    if (!textIndex) return false;\n    // More then one means it is a contraction.\n    if (textIndex.length > 1) return false;\n    // Outside intrinsic vocab means OOV again.\n    if (textIndex[0] >= lexemeIntrinsicSize) return false;\n    // If it is not a base form so point in checking same POS — basics of\n    // lemmatization. For example, `hiding` becomes `hid` on removal of `-ing`,\n    // which is not in base form (i.e. hid is the past tense of hide); so it should\n    // not take that as the lemma and instead try adding `-e`.\n    if (property(textIndex, 'isBaseForm') === 0) return false;\n    // Finally if it is in base form then check for pos membership.\n    return isMemberPOS(textIndex[0], model.pos.hash[pos]);\n  }; // hasSamePOS()\n\n  // ## isOOV\n  /**\n   *\n   * Tests the input `text` for being an OOV.\n   *\n   * @param {text} text that needs to be test for OOV.\n   * @return {boolean} true if OOV otherwise false (in vocab).\n   * @private\n  */\n  var isOOV = function (text) {\n    var textIndex = lookup(text);\n    if (!textIndex) return true;\n    if (textIndex.length > 1) return false;\n    if (textIndex[0] >= lexemeIntrinsicSize) return true;\n    return false;\n  }; // isOOV()\n\n  methods.add = add;\n  methods.lookup = lookup;\n  methods.value = value;\n  methods.property = property;\n  methods.normal = normal;\n  methods.nox = nox;\n  methods.posOf = posOf;\n  methods.valueOf = valueOf;\n  methods.currentSize = currentSize;\n  methods.intrinsicSize = intrinsicSize;\n  methods.isOOV = isOOV;\n  methods.isMemberPOS = isMemberPOS;\n  methods.hasSamePOS = hasSamePOS;\n  methods.mappedSpelling = mappedSpelling;\n  return methods;\n}; // cache()\n\nmodule.exports = cache;","map":{"version":3,"names":["constants","require","xnMask","bits4PrecedingSpace","xcMask","bits4xpPointer","cache","model","featureFn","fTokenType","methods","Object","create","lexemesHash","features","lexeme","hash","lxm","lexemeIntrinsicSize","intrinsicSize","layout","packing","pkSize","size","efSize","efList","efListSize","length","lexicon","xpansions","posClusters","list","extrinsicLexicon","elBasePackingSize","elPackingSize","efArray","Uint32Array","feature","config","efHash","tokenType","forEach","ef","getFeaturesIndex","name","value","f","h","l","isNewValue","index","undefined","push","add","text","category","normText","toLowerCase","textIndex","normIndex","cfg","fv","fv4p","k","fill","lookup","layout4isContraction","isContraction","layout4lemma","lemma","cc","cx","cxi","tokens","normal","layout4normal","layout4mapped","isSpellingMapped","oovIdx","mappedSpelling","mappedIndex","nox","binaryWord","property","prop","propValue","layout4Prop","isMemberPOS","lexemeIdx","posIdx","has","posOf","posValue","pos","valueOf","currentSize","hasSamePOS","isOOV","module","exports"],"sources":["C:/Users/cheko/Desktop/Education/Freelance/criticowl-main/criticowl_frontend/node_modules/wink-nlp/src/cache.js"],"sourcesContent":["//     wink-nlp\n//\n//     Copyright (C) GRAYPE Systems Private Limited\n//\n//     This file is part of “wink-nlp”.\n//\n//     Permission is hereby granted, free of charge, to any\n//     person obtaining a copy of this software and\n//     associated documentation files (the \"Software\"), to\n//     deal in the Software without restriction, including\n//     without limitation the rights to use, copy, modify,\n//     merge, publish, distribute, sublicense, and/or sell\n//     copies of the Software, and to permit persons to\n//     whom the Software is furnished to do so, subject to\n//     the following conditions:\n//\n//     The above copyright notice and this permission notice\n//     shall be included in all copies or substantial\n//     portions of the Software.\n//\n//     THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF\n//     ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED\n//     TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A\n//     PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL\n//     THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,\n//     DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF\n//     CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN\n//     CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER\n//     DEALINGS IN THE SOFTWARE.\n\n//\n\nvar constants = require( './constants.js' );\nvar xnMask = constants.xnMask;\nvar bits4PrecedingSpace = constants.bits4PrecedingSpace;\nvar xcMask = constants.xcMask;\nvar bits4xpPointer = constants.bits4xpPointer;\n\n// ## cache\n/**\n *\n * Creates an instance of `cache`. It is typically instantiated in each `winkNLP`\n * instance and there it is responsible for caching token properties acrosss the\n * documents i.e. the `doc()`.\n *\n * @param {Array} model containing language model.\n * @param {Array} featureFn extracts language specific features of a lexeme.\n * @return {object} of methods.\n * @private\n*/\nvar cache = function ( model, featureFn ) {\n  const fTokenType = 'tokenType';\n  // Returned!\n  var methods = Object.create( null );\n  // Extract frequently used properties.\n  var lexemesHash = model.features.lexeme.hash;\n  var lxm = model.features.lexeme;\n  var lexemeIntrinsicSize = model.features.lexeme.intrinsicSize;\n  var layout = model.packing.layout;\n  var pkSize = model.packing.size;\n  var efSize = model.packing.efSize;\n  var efList = model.packing.efList;\n  var efListSize = efList.length;\n  var lexicon = model.lexicon;\n  var xpansions = model.xpansions;\n  var posClusters = model.features.posClusters.list;\n  // Contains quantas of UInt32Array of size `model.packing.size`. A quanta\n  // at an `index` contains the features of the corresponding OOV lexeme loacted\n  // at `model.features.lexeme.list[ index ]`. This simplifies information access,\n  // as it remains identical to the **intrinsic lexicon** with the only difference\n  // that this not a continuous array of UInt32s. It follows\n  // `[ normal, lemma, <extractable features> ]` structure. The extractable\n  // features will be dynamically determined using the language model.\n  var extrinsicLexicon = [];\n  // Base Packing Size is `2` because one word each for normal & lemma is needed.\n  var elBasePackingSize = 2;\n  // Packing size for each lexeme in `extrinsicLexicon` — base plus additional\n  // words needed for extractable features.\n  var elPackingSize = 2 + efSize;\n  // Extractable Features temp storage; eventually its contents will be pushed\n  // inside `extrinsicLexicon`. Space is allocated right in the beginning to save\n  // time. Its contents are filled i.e. initialized with 0 whenever needed.\n  var efArray = new Uint32Array( efSize );\n\n  var feature = featureFn( model.packing.config );\n\n  // Extractable Features Hash: used during property extraction for OOV tokens.\n  // If a token is not found in this then a **0** is returned.\n  var efHash = Object.create( null );\n  // Since `tokenType` is determined during tokenization, it is always extractable.\n  efHash.tokenType = true;\n  // Copy rest from the list in to the hash.\n  efList.forEach( ( ef ) => ( efHash[ ef ] = true ) );\n\n  // ## getFeaturesIndex\n  /**\n   *\n   * Returns the `index` of `value` from the feature `name`. If the value is\n   * missing then it is added and its `index` is returned accordingly alongwith\n   * a flag indicating that it is a new value.\n   *\n   * @param {string} name of the feature.\n   * @param {string} value of the feature, whoes index will be returned.\n   * @return {number[]} `[ isNewValue, index ]`.\n   * @example\n   * // Returns the index (hash) of **lexeme** – `you`:\n   * getFeaturesIndex( 'lexeme', 'you' );\n   * // -> [ 0, 47 ]\n   * // If `you` was absent then it would have been added and the return value\n   * // would have been [ 1, index of added value ]\n   * @private\n  */\n  var getFeaturesIndex = function ( name, value ) {\n    // Extract the named feature.\n    var f = model.features[ name ];\n    // And its hash & list.\n    var h = f.hash;\n    var l = f.list;\n    // New `value` flag.\n    var isNewValue = 0;\n    // Check if `value` is present.\n    var index = h[ value ];\n    if ( index === undefined ) {\n      // Feature's storage limit check. — not required right now!\n      // if ( f.index > f.maxIndex ) {\n      //   throw Error( `wink-nlp: memory limit for \"${name}\" exceeded.` );\n      // }\n      // Missing — add `value`.\n      index = h[ value ] = f.index;\n      // No need to increment index because push returns the required value!\n      f.index = l.push( value );\n      // Set new value flag.\n      isNewValue = 1;\n    }\n    return [ isNewValue, index ];\n  }; // getFeaturesIndex()\n\n  // ## add\n  /**\n   *\n   * Adds a token in the cache corresponding to the **text**. If the same is\n   * present in the cache then a pointer to its cached value is retured; otherwise\n   * a new entry is made in the cache and the same is returned.\n   *\n   * Whenever a new entry is made, all its extractable features are also\n   * extracted & packed; and if an extractable feature is also new, its entry\n   * is also made via `getFeaturesIndex()` api.\n   *\n   * @param {string} text i.e. the value of the token to be added.\n   * @param {number} category of the token i.e. `word(0)` or `number(1)`, etc.\n   * @return {number[]} index (or hash) of the `text` added.\n   * @private\n  */\n  var add = function ( text, category ) {\n    // Lowercased `text`.\n    var normText = text.toLowerCase();\n    // First start with `text` as its properties are being processed first.\n    var textIndex = getFeaturesIndex( 'lexeme', text );\n    // Then obtain index of its normal.\n    var normIndex = ( normText === text ) ? textIndex : getFeaturesIndex( 'lexeme', normText );\n    // Helpers: cfg of feature, feature, feature's value, feature's value for\n    // packing & loop index.\n    var cfg, f, fv, fv4p, k;\n\n    // Process properties of `text` first.\n    // The `textIndex[ 0 ]` is a indicated if the value is newly added, and if\n    // so then add extract-able features. See `getFeaturesIndex()` above.\n    if ( textIndex[ 0 ] ) {\n      // NOTE: This block of code is repeated below, with an exception that\n      // in the next block we use `normtext` in `fv = feature[ f ]( text )`.\n      // Intialize extractable featires' array with all 0s.\n      efArray.fill( 0 );\n      // For every extractable feature, extract & pack.\n      for ( k = 0; k < efListSize; k += 1 ) {\n        f = efList[ k ];\n        cfg = layout[ f ];\n        // Use `text`.\n        fv = feature[ f ]( text, category, methods );\n        fv4p = ( cfg[ 3 ] ) ? fv : getFeaturesIndex( f, fv )[ 1 ];\n        efArray[ cfg[ 0 ] ] |= ( fv4p << cfg[ 2 ] ); // eslint-disable-line no-bitwise\n      } // for\n      // Pack token type now.\n      f = fTokenType;\n      cfg = layout[ f ];\n      efArray[ cfg[ 0 ] ] |= ( category << cfg[ 2 ] ); // eslint-disable-line no-bitwise\n      // Push all the details i.e. `[ normal, lemma, <extractable features> ]`\n      // into `extrinsicLexicon`.\n      extrinsicLexicon.push( normIndex[ 1 ], normIndex[ 1 ], ...efArray );\n    } // if ( >= lexemeIntrinsicSize )\n\n    // If the normalized text is not same as the original text then the\n    // normalize text's extract-able features could be candidates for addition.\n    if ( textIndex[ 1 ] !== normIndex[ 1 ] ) {\n      // Has it been newly added? If Yes, add its extract-able features.\n      if ( normIndex[ 0 ] ) {\n        // NOTE: This block of code is same as above.\n        // Intialize extractable featires' array with all 0s.\n        efArray.fill( 0 );\n        // For every extractable feature, extract & pack.\n        for ( k = 0; k < efListSize; k += 1 ) {\n          f = efList[ k ];\n          cfg = layout[ f ];\n          // Use `normText`.\n          fv = feature[ f ]( normText, category, methods );\n          fv4p = ( cfg[ 3 ] ) ? fv : getFeaturesIndex( f, fv )[ 1 ];\n          efArray[ cfg[ 0 ] ] |= ( fv4p << cfg[ 2 ] ); // eslint-disable-line no-bitwise\n        } // for\n        // Pack token type now.\n        f = fTokenType;\n        cfg = layout[ f ];\n        efArray[ cfg[ 0 ] ] |= ( category << cfg[ 2 ] ); // eslint-disable-line no-bitwise\n        // Push all the details i.e. `[ normal, lemma, <extractable features> ]`\n        // into `extrinsicLexicon`.\n        extrinsicLexicon.push( normIndex[ 1 ], normIndex[ 1 ], ...efArray );\n      } // if ( >= lexemeIntrinsicSize )\n    } // if ( textIndex !== normIndex )\n\n    // Return the `textIndex` only – this can be sued to extract properties.\n    return ( textIndex[ 1 ] );\n  }; // add()\n\n  // ## lookup\n  /**\n   *\n   * Looks up for the `text` in the cache and returns its index. If the input\n   * text is a contraction then its expansions are returned.\n   *\n   * @param {string} text to be searched in the cache.\n   * @return {number[]} contains either a single element (i.e. `index`) indicating\n   * that it is NOT a contraction or multiple elements indication that the text\n   * is a contraction. Each contraction expands into 4 elements viz. `lexeme`,\n   * `normal`, `lemma` , and `pos`.\n   * @private\n  */\n  var lookup = function ( text ) {\n    // `layout.isContraction` for multiple use later.\n    var layout4isContraction = layout.isContraction;\n    var layout4lemma = layout.lemma;\n    // `index` to `text`.\n    var index = lexemesHash[ text ];\n    // Holds lemma extracted in case of contraction.\n    var lemma;\n    // Contraction Count, Contraction Index, Loop Index.\n    var cc, cx, cxi;\n\n    // If the text is not found, return `null`.\n    if ( index === undefined ) return null;\n    // `text` is found – need to check for contraction if `text` is not an OOV.\n    var tokens = [];\n    var isContraction;\n    if ( index < lexemeIntrinsicSize ) {\n      // Not an OOV, check it it is a contraction.\n      isContraction = ( lexicon[ layout4isContraction[ 0 ] + ( index * pkSize ) ] & layout4isContraction[ 1 ] ) >>> layout4isContraction[ 2 ]; // eslint-disable-line no-bitwise\n      if ( isContraction ) {\n        // It is a contraction, process its expansions.\n        // Start by extracting lemma, as it contains pointer to `expansions` and their count.\n        lemma  = ( lexicon[ layout4lemma[ 0 ] + ( index * pkSize ) ] & layout4lemma[ 1 ] ) >>> layout4lemma[ 2 ]; // eslint-disable-line no-bitwise\n        // Extract pointer (i.e. index) to expansions and their count.\n        cx = lemma & 0x3FFF; // eslint-disable-line no-bitwise\n        cc = ( lemma & ( xcMask << bits4xpPointer ) ) >> bits4xpPointer; // eslint-disable-line no-bitwise\n        // Iterate through `cc` times to push details into the `tokens`.\n        for ( cxi = 0; cxi < cc; cxi += 4 ) {\n          tokens.push(\n            xpansions[ cx + cxi ],      // lexeme\n            cx + cxi + 1,               // normal (pointer to xpansion & not to lexicon)\n            xpansions[ cx + cxi + 2 ],  // lemma\n            xpansions[ cx + cxi + 3 ]   // pos\n          );\n        }\n      } else {\n        // Not a contraction, simply add `text`'s `index` to `tokens`.\n        tokens.push( index );\n      }\n    } else {\n      // An OOV, only add `text`'s `index` to `tokens`.\n      tokens.push( index );\n    }\n    return tokens;\n  }; // lookup()\n\n  // ## value\n  /**\n   *\n   * Returns the value corresponding to the `index`.\n   *\n   * @param {number} index for the value.\n   * @return {string} value corresponding to the `index`.\n   * @private\n  */\n  var value = function ( index ) {\n    return lxm.list[ index ];\n  }; // value()\n\n  // ## normal\n  /**\n   *\n   * Returns the index of normal of the input `index` (of required lexeme) after\n   * taking into account mapping of spelling, if any.\n   *\n   * @param {number} index of the required lexeme.\n   * @return {string} index to the normal.\n   * @private\n  */\n  var normal = function ( index ) {\n    // Temps for `layput.normal`, `layout.isSpellingMapped`, etc.\n    var layout4normal = layout.normal;\n    var layout4mapped = layout.isSpellingMapped;\n    var layout4lemma =  layout.lemma;\n    // Used to remap if its value is `1`. In this case lemma becomes the `normIndex`.\n    var isSpellingMapped;\n    // Index for OOVs i.e. when `index > lexemeIntrinsicSize`.\n    var oovIdx;\n    // Returned: normal's index.\n    var normIndex;\n\n    // Processing is different for native and OOV words or lexemes. For OOVs\n    // properties have to be extracted from `extrinsicLexicon`, whereas for\n    // native words they are exracted from `lexicon`.\n    if ( index < lexemeIntrinsicSize ) {\n      normIndex = ( lexicon[ layout4normal[ 0 ] + ( index * pkSize ) ] & layout4normal[ 1 ] ) >>> layout4normal[ 2 ]; // eslint-disable-line no-bitwise\n      isSpellingMapped = ( lexicon[ layout4mapped[ 0 ] + ( index * pkSize ) ] & layout4mapped[ 1 ] ) >>> layout4mapped[ 2 ]; // eslint-disable-line no-bitwise\n      if ( isSpellingMapped ) {\n        // Mapped, pick up the lemma portion as this points to normal in case of\n        // mapped spellings.\n        normIndex = ( lexicon[ layout4lemma[ 0 ] + ( index * pkSize ) ] & layout4lemma[ 1 ] ) >>> layout4lemma[ 2 ]; // eslint-disable-line no-bitwise\n      } else {\n        // Compute actual index from the relative index.\n        normIndex += index;\n      }\n    } else {\n      oovIdx = index - lexemeIntrinsicSize;\n      // Refer to `extrinsicLexicon` structure at the top of `cache()`.\n      normIndex = extrinsicLexicon[ oovIdx * elPackingSize ];\n      // This `normIndex` may point to an intrinsic lexeme, in which case\n      // mapping needs to be checked.\n      if ( normIndex < lexemeIntrinsicSize ) {\n        isSpellingMapped = ( lexicon[ layout4mapped[ 0 ] + ( normIndex * pkSize ) ] & layout4mapped[ 1 ] ) >>> layout4mapped[ 2 ]; // eslint-disable-line no-bitwise\n        if ( isSpellingMapped ) {\n          normIndex = ( lexicon[ layout4lemma[ 0 ] + ( normIndex * pkSize ) ] & layout4lemma[ 1 ] ) >>> layout4lemma[ 2 ]; // eslint-disable-line no-bitwise\n        }\n      }\n    }\n\n    return normIndex;\n  }; // normal()\n\n  // ## mappedSpelling\n  /**\n   *\n   * Returns the index of mapped spelling's of the input `index` of required lexeme.\n   *\n   * @param {number} index of the required lexeme.\n   * @return {string} index to the normal.\n   * @private\n  */\n  var mappedSpelling = function ( index ) {\n    // Temps for `layout.isSpellingMapped`, etc.\n    var layout4mapped = layout.isSpellingMapped;\n    var layout4lemma =  layout.lemma;\n    // Used to remap if its value is `1`. In this case lemma becomes the `normIndex`.\n    var isSpellingMapped;\n    // Returned: normal's index.\n    var mappedIndex = index;\n\n    // Only applicable to lexems that are inside the vocabulary as there can not\n    // be mapped spelling for OOV words!\n    if ( index < lexemeIntrinsicSize ) {\n      isSpellingMapped = ( lexicon[ layout4mapped[ 0 ] + ( index * pkSize ) ] & layout4mapped[ 1 ] ) >>> layout4mapped[ 2 ]; // eslint-disable-line no-bitwise\n      if ( isSpellingMapped ) {\n        // Mapped, pick up the lemma portion as this points to normal in case of\n        // mapped spellings.\n        mappedIndex = ( lexicon[ layout4lemma[ 0 ] + ( index * pkSize ) ] & layout4lemma[ 1 ] ) >>> layout4lemma[ 2 ]; // eslint-disable-line no-bitwise\n      }\n    }\n\n    return mappedIndex;\n  }; // mappedSpelling()\n\n  // ## nox\n  /**\n   *\n   * Returns the index of normal of the expansion.\n   *\n   * @param {number} binaryWord containing pointer to `xpansions` and `precedingSpaces`;\n   * It is the 2nd (relative) element of a single token's packet of 4-words.\n   * @return {number} index to the normal, whoes value can be found via `value()`.\n   * @private\n  */\n  var nox = function ( binaryWord ) {\n    return xpansions[ ( binaryWord & xnMask) >>> bits4PrecedingSpace ];  // eslint-disable-line no-bitwise\n  }; // nox()\n\n  // ## property\n  /**\n   *\n   * Extracts the property – `prop` of a lexeme (or word) specified by `index`.\n   *\n   * @param {number} index of the lexeme whoes properties are required to be extracted.\n   * @param {string} prop (name) that needs to be extracted — it should be a valid property.\n   * @return {string} extracted property, if `prop` is known/valid otherwise `null`.\n   * @private\n  */\n  var property = function ( index, prop ) {\n    // A property and its value\n    var propValue;\n    // Index for OOVs i.e. when `index > lexemeIntrinsicSize`.\n    var oovIdx;\n    // Temp for `layput[ p ]`\n    var layout4Prop;\n\n    // Processing is different for native and OOV words or lexemes. For OOVs\n    // properties have to be extracted from `extrinsicLexicon`, whereas for\n    // native words they are exracted from `lexicon`.\n    if ( index < lexemeIntrinsicSize ) {\n      layout4Prop = layout[ prop ];\n      if ( layout4Prop  === undefined ) return null;\n      propValue  = ( lexicon[ layout4Prop[ 0 ] + ( index * pkSize ) ] & layout4Prop[ 1 ] ) >>> layout4Prop[ 2 ]; // eslint-disable-line no-bitwise\n      // Use hash/list to update value if required.\n      if ( layout4Prop[ 3 ] === 0 || layout4Prop[ 5 ] === 1 ) propValue = model.features[ prop ].list[ propValue ];\n    } else {\n        // Attempt extraction only if extractable!\n        if ( !efHash[ prop ] ) return 0;\n        // Compute index into `extrinsicLexicon`.\n        oovIdx = index - lexemeIntrinsicSize;\n        layout4Prop = layout[ prop ];\n        // No need for this check as `if ( !efHash[ prop ] )...` ensures return\n        // in case of any unknown property:\n        /* if ( layout4Prop  === undefined ) return null; */\n        // Use `extrinsicLexicon`.\n\n        // Reach to the desired quanta via `oovIdx * elPackingSize`, move forward by `base size` and then go to offset!\n        propValue  = ( extrinsicLexicon[ ( oovIdx * elPackingSize ) + elBasePackingSize + layout4Prop[ 0 ] ] & layout4Prop[ 1 ] ) >>> layout4Prop[ 2 ]; // eslint-disable-line no-bitwise\n        // Use hash/list to update value if required.\n        if ( layout4Prop[ 3 ] === 0 || layout4Prop[ 5 ] === 1 ) propValue = model.features[ prop ].list[ propValue ];\n    }\n    return propValue;\n  }; // property()\n\n  var isMemberPOS = function ( lexemeIdx, posIdx ) {\n    // Dont miss converting posIdx to a number.\n    return posClusters[ property( lexemeIdx, 'lexemeCID' ) ].has( +posIdx );\n  }; // isMemberPOS()\n\n  // ## posOf\n  /**\n   *\n   * Extracts the pos' index of the a lexeme (or word) specified by `index`.\n   *\n   * @param {number} index of the lexeme whoes properties are required to be extracted.\n   * @return {string[]} extracted properties in the same sequence as `list`.\n   * @private\n  */\n  var posOf = function ( index ) {\n    // Value of extracted pos will go here.\n    var posValue;\n    // Index for OOVs i.e. when `index > lexemeIntrinsicSize`.\n    var oovIdx;\n    // Temp for `layput[ p ]`\n    var layout4Prop;\n\n    // Processing is different for native and OOV words or lexemes. For OOVs\n    // properties have to be extracted from `extrinsicLexicon`, whereas for\n    // native words they are exracted from `lexicon`.\n    if ( index < lexemeIntrinsicSize ) {\n        layout4Prop = layout.pos;\n        posValue  = ( lexicon[ layout4Prop[ 0 ] + ( index * pkSize ) ] & layout4Prop[ 1 ] ) >>> layout4Prop[ 2 ]; // eslint-disable-line no-bitwise\n    } else {\n        // Compute index into `extrinsicLexicon`.\n        oovIdx = index - lexemeIntrinsicSize;\n        layout4Prop = layout.pos;\n\n        // Use `extrinsicLexicon`.\n        // Reach to the desired quanta via `oovIdx * elPackingSize`, move forward by `base size` and then go to offset!\n        posValue  = ( extrinsicLexicon[ ( oovIdx * elPackingSize ) + elBasePackingSize + layout4Prop[ 0 ] ] & layout4Prop[ 1 ] ) >>> layout4Prop[ 2 ]; // eslint-disable-line no-bitwise\n    }\n    return posValue;\n  }; // posOf()\n\n  // ## valueOf\n  /**\n   *\n   * Extracts the value of the `prop`erty for its input `index`.\n   *\n   * @param {string} prop to be extracted for the `index`.\n   * @param {number} index of the property.\n   * @return {string[]} extracted properties in the same sequence as `list`.\n   * @private\n  */\n  var valueOf = function ( prop, index ) {\n    return model.features[ prop ].list[ index ];\n  }; // valueOf()\n\n  // ## currentSize\n  /**\n   *\n   * Returns the current size of lexicon including OOVs.\n   *\n   * @return {number} size of the current lexicon.\n   * @private\n  */\n  var currentSize = function () {\n    // Minus `1` becuase at `0` we have OOV symbolic word.\n    return ( lxm.list.length - 1 );\n  }; // size()\n\n  // ## intrinsicSize\n  /**\n   *\n   * Returns the intrinsic i.e. native size of lexicon.\n   *\n   * @return {number} size of the native or intrinsic lexicon.\n   * @private\n  */\n  var intrinsicSize = function () {\n    return lexemeIntrinsicSize;\n  };\n\n  /**\n   * Finds if the text can have `pos` as valid part of speech, provided it is a\n   * base form. Used in **lemmatization** to see if the lemma shares the same pos\n   * with the original word.\n   *\n   * @param  {string} text  the incoming word.\n   * @param  {string} pos   the pos that needs to be checked as one of the valid pos for text.\n   * @return {boolean}       True if it does, otherwise false.\n   */\n  var hasSamePOS = function ( text, pos ) {\n    // Get the word's index\n    var textIndex = lookup( text );\n    // If not found i.e. OOV means that it did not have a pre-defined POS set.\n    if ( !textIndex ) return false;\n    // More then one means it is a contraction.\n    if ( textIndex.length > 1 ) return false;\n    // Outside intrinsic vocab means OOV again.\n    if ( textIndex[ 0 ] >= lexemeIntrinsicSize ) return false;\n    // If it is not a base form so point in checking same POS — basics of\n    // lemmatization. For example, `hiding` becomes `hid` on removal of `-ing`,\n    // which is not in base form (i.e. hid is the past tense of hide); so it should\n    // not take that as the lemma and instead try adding `-e`.\n    if ( property( textIndex, 'isBaseForm' ) === 0 ) return false;\n    // Finally if it is in base form then check for pos membership.\n    return isMemberPOS( textIndex[ 0 ], model.pos.hash[ pos ] );\n  }; // hasSamePOS()\n\n  // ## isOOV\n  /**\n   *\n   * Tests the input `text` for being an OOV.\n   *\n   * @param {text} text that needs to be test for OOV.\n   * @return {boolean} true if OOV otherwise false (in vocab).\n   * @private\n  */\n  var isOOV = function ( text ) {\n    var textIndex = lookup( text );\n    if ( !textIndex ) return true;\n    if ( textIndex.length > 1 ) return false;\n    if ( textIndex[ 0 ] >= lexemeIntrinsicSize ) return true;\n    return false;\n  }; // isOOV()\n\n  methods.add = add;\n  methods.lookup = lookup;\n  methods.value = value;\n  methods.property = property;\n  methods.normal = normal;\n  methods.nox = nox;\n  methods.posOf = posOf;\n  methods.valueOf = valueOf;\n  methods.currentSize = currentSize;\n  methods.intrinsicSize = intrinsicSize;\n  methods.isOOV = isOOV;\n  methods.isMemberPOS = isMemberPOS;\n  methods.hasSamePOS = hasSamePOS;\n  methods.mappedSpelling = mappedSpelling;\n\n  return methods;\n}; // cache()\n\nmodule.exports = cache;\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"script","externalDependencies":[]}