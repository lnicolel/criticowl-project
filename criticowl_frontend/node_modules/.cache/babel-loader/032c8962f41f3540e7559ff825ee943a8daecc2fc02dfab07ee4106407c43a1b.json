{"ast":null,"code":"//     wink-nlp\n//\n//     Copyright (C) GRAYPE Systems Private Limited\n//\n//     This file is part of “wink-nlp”.\n//\n//     Permission is hereby granted, free of charge, to any\n//     person obtaining a copy of this software and\n//     associated documentation files (the \"Software\"), to\n//     deal in the Software without restriction, including\n//     without limitation the rights to use, copy, modify,\n//     merge, publish, distribute, sublicense, and/or sell\n//     copies of the Software, and to permit persons to\n//     whom the Software is furnished to do so, subject to\n//     the following conditions:\n//\n//     The above copyright notice and this permission notice\n//     shall be included in all copies or substantial\n//     portions of the Software.\n//\n//     THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF\n//     ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED\n//     TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A\n//     PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL\n//     THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,\n//     DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF\n//     CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN\n//     CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER\n//     DEALINGS IN THE SOFTWARE.\n\n//\n\n/* eslint-disable no-underscore-dangle */\n/* eslint-disable no-console */\n\nvar containedEntities = require('./contained-entities.js');\n\n// ### Helper Functions\n\n// Get **item at** collection, selection & parent.\nvar getParentItem = require('./api/get-parent-item.js');\nvar colGetItemAt = require('./api/col-get-item.js');\nvar selGetItemAt = require('./api/sel-get-item.js');\n\n// **Each** iterator for collection & selection.\nvar colEach = require('./api/col-each.js');\nvar selEach = require('./api/sel-each.js');\n\n// **Filter** for collection & selection.\nvar colFilter = require('./api/col-filter.js');\nvar selFilter = require('./api/sel-filter.js');\n\n// **Token's out** for item, collection & selection.\nvar itmTokenOut = require('./api/itm-token-out.js');\nvar colTokensOut = require('./api/col-tokens-out.js');\nvar selTokensOut = require('./api/sel-tokens-out.js');\n\n// **Entity's out** for item, collection & selection.\nvar itmEntityOut = require('./api/itm-entity-out.js');\nvar colEntitiesOut = require('./api/col-entities-out.js');\nvar selEntitiesOut = require('./api/sel-entities-out.js');\n\n// **Sentence's out** for item, collection & selection.\nvar itmSentenceOut = require('./api/itm-sentence-out.js');\nvar colSentencesOut = require('./api/col-sentences-out.js');\n\n// **Document's out** for item.\nvar itmDocumentOut = require('./api/itm-document-out.js');\n\n// Print tokens, it is primarily for command line output.\nvar printTokens = require('./api/print-tokens.js');\nvar its = require('./its.js');\n\n// <hr/>\n\n// # Doc\n/**\n *\n * The wink-nlp **doc**ument – constructed in `wink-nlp.js` – publishes the\n * developer APIs.\n *\n * @param  {object} docData     It encapsulates the document data.\n * @param  {object} addons      The model's addon, may contain word vectors, stemmer etc.\n * @return {object}             conatining APIs.\n * @private\n */\nvar doc = function (docData, addons) {\n  // Extract `cache` as it is frequently accessed.\n  var cache = docData.cache;\n\n  // Document's tokens; each token is represented as an array of numbers:\n  // ```\n  // [\n  //   hash, // of tokenized lexeme\n  //   (nox) + preceding spaces, // expansion's normal\n  //   pos + lemma, // pos & lemma are contextual\n  //   entity + sentence // 12bit + 20bits\n  // ]\n  // ```\n  var tokens = docData.tokens;\n\n  // Entities — sorted as array of `[ start, end, entity type ].`\n  var entities = docData.entities;\n  var customEntities = docData.customEntities;\n\n  // Sentences — sorted as array of pairs of `[ start, end ]` pointing to the `tokens`.\n  var sentences = docData.sentences;\n\n  // Markings are 4-tuples of `start`, `end` **token indexes**,  and `begin & end markers`.\n  // The begin & end markers are used to markup the tokens specified.\n  var markings = docData.markings;\n\n  // #### API core functions:\n\n  // Collection APIs.\n  var colEntities;\n  var colCustomEntities;\n  var colTokens;\n  var colSentences;\n\n  // Selection — obtained via `filter` — APIs. It is also like a collection.\n  var colSelectedEntities;\n  var colSelectedCustomEntities;\n  var colSelectedTokens;\n\n  // Item APIs.\n  var itemToken;\n  var itemEntity;\n  var itemCustomEntity;\n  var itemSentence;\n\n  // Vectors API\n  var contextualVectors;\n\n  // Others.\n  var isLexeme = cache.lookup;\n\n  // The Document — Returned!\n  var methods = Object.create(null);\n\n  // ## Token\n  // **Item, Collection, and Selection APIs.**\n\n  // ### itemToken\n  /**\n   *\n   * Makes item of the token specified at `index`.\n   *\n   * @param  {number} index The index of the token, which is required to be returned as item token.\n   * @return {object}       containing applicable API methods.\n   * @private\n   */\n  itemToken = function (index) {\n    var api = Object.create(null);\n    // Access the parent document.\n    api.parentDocument = () => methods;\n    // Access the parent entity, **if any.**\n    api.parentEntity = () => getParentItem(index, entities, itemEntity);\n    // Access the parent cuustom entity, **if any.**\n    api.parentCustomEntity = () => getParentItem(index, customEntities, itemCustomEntity);\n    // Markup this token.\n    api.markup = (beginMarker, endMarker) => markings.push([index, index, beginMarker, endMarker]);\n    // Output this token or its properties using mapper function — `f`.\n    api.out = f => itmTokenOut(index, docData, f, addons);\n    // Access the parent sentence.\n    api.parentSentence = () => getParentItem(index, sentences, itemSentence);\n    // Index within the document.\n    api.index = () => index;\n    return api;\n  }; // itemToken()\n\n  // ### colSelectedTokens\n  /**\n   *\n   * Makes collection of tokens identified by the `selectedTokens` array.\n   *\n   * @param  {array} selectedTokens The array of selected tokens, using which the\n   *                                collection is made.\n   * @return {object}               containing applicable API methods.\n   * @private\n   */\n  colSelectedTokens = function (selectedTokens) {\n    var api = Object.create(null);\n    // Iterator.\n    api.each = f => selEach(f, selectedTokens, itemToken);\n    // Filter.\n    api.filter = f => selFilter(f, selectedTokens, itemToken, colSelectedTokens);\n    // Item at `k`th index. If `k` is outside valid range, return `undefined` like JS.\n    api.itemAt = k => selGetItemAt(k, selectedTokens, itemToken);\n    // Number of selected tokens.\n    api.length = () => selectedTokens.length;\n    // Output this collection of selected tokens as a reduced values or properties\n    // using map/reduce functions — `f/g`.\n    api.out = (f, g) => selTokensOut(selectedTokens, docData, f, g, addons);\n    return api;\n  }; // colTokens()\n\n  // ### colTokens\n  /**\n   *\n   * Makes collection of tokens beginning from `start` index to `end` index.\n   *\n   * @param  {number} start The start index.\n   * @param  {number} end   The end index.\n   * @return {object}       containing applicable API methods.\n   * @private\n   */\n  colTokens = function (start, end) {\n    return function () {\n      var api = Object.create(null);\n      // Iterator.\n      api.each = f => colEach(f, start, end, itemToken);\n      // Filter.\n      api.filter = f => colFilter(f, start, end, itemToken, colSelectedTokens);\n      // Item at `k`th index. If `k` is outside valid range, return `undefined` like JS.\n      // No need to handle relative indexing as `colGetItemAt` handles it.\n      api.itemAt = k => colGetItemAt(k, start, end, itemToken);\n      // Length of this collection.\n      api.length = () => end - start + 1;\n      // Output this token collection as a reduced values or properties using\n      // map/reduce functions — `f/g`.\n      api.out = (f, g) => colTokensOut(start, end, docData, f, g, addons);\n      return api;\n    };\n  }; // colTokens()\n\n  // <hr/>\n\n  // ## Entity\n  // **Item, Collection, and Selection APIs.**\n\n  // ### itemEntity\n  /**\n   *\n   * Makes item of the entity specified at `index`.\n   *\n   * @param  {number} index The index of the entity, which is required to be\n   *                        returned as item entity.\n   * @return {object}       containing applicable API methods.\n   * @private\n   */\n  itemEntity = function (index) {\n    var api = Object.create(null);\n    // Access the parent document.\n    api.parentDocument = () => methods;\n    // Markup this entity.\n    api.markup = (beginMarker, endMarker) => markings.push([entities[index][0], entities[index][1], beginMarker, endMarker]);\n    // Output this entity or its properties using mapper function — `f`.\n    api.out = f => itmEntityOut(index, entities, docData, f);\n    // Access the parent sentence.\n    api.parentSentence = () => getParentItem(entities[index][0], sentences, itemSentence);\n    // Retun collection of tokens contained in this entity.\n    api.tokens = colTokens(entities[index][0], entities[index][1]);\n    // Index within the document.\n    api.index = () => index;\n    return api;\n  }; // itemEntity()\n\n  // ### colSelectedEntities\n  /**\n   *\n   * Makes collection of entities identified by the `selectedEntities` array.\n   *\n   * @param  {array} selectedEntities The array of selected entities, using which\n   *                                  the collection is made.\n   * @return {object}                 containing applicable API methods.\n   * @private\n   */\n  colSelectedEntities = function (selectedEntities) {\n    var api = Object.create(null);\n    // Iterator.\n    api.each = f => selEach(f, selectedEntities, itemEntity);\n    // Filter.\n    api.filter = f => selFilter(f, selectedEntities, itemEntity, colSelectedEntities);\n    // Item at `k`th index. If `k` is outside valid range, return `undefined` like JS.\n    api.itemAt = k => selGetItemAt(k, selectedEntities, itemEntity);\n    // Number of selected entities.\n    api.length = () => selectedEntities.length;\n    // Output this collectionn of selected of entities as a reduced value\n    // using map/reduce functions — `f/g`.\n    api.out = (f, g) => selEntitiesOut(selectedEntities, entities, docData, f, g);\n    return api;\n  }; // colSelectedEntities()\n\n  // ### colEntities\n  /**\n   *\n   * Makes collection of all the entities.\n   *\n   * @return {object} containing applicable API methods.\n   * @private\n   */\n  colEntities = function () {\n    var api = Object.create(null);\n    // Iterator.\n    api.each = f => colEach(f, 0, entities.length - 1, itemEntity);\n    // Filter.\n    api.filter = f => colFilter(f, 0, entities.length - 1, itemEntity, colSelectedEntities);\n    // Item at `k`th index. If `k` is outside valid range, return `undefined` like JS.\n    api.itemAt = k => colGetItemAt(k, 0, entities.length - 1, itemEntity);\n    // Length of this collection.\n    api.length = () => entities.length;\n    // Output this collection of entities as a reduced value\n    // using map/reduce functions — `f/g`.\n    api.out = (f, g) => colEntitiesOut(entities, docData, f, g);\n    return api;\n  }; // colEntities()\n\n  // <hr/>\n\n  // ## Entity\n  // **Item, Collection, and Selection APIs.**\n\n  // ### itemCustomEntity\n  /**\n   *\n   * Makes item of the entity specified at `index`.\n   *\n   * @param  {number} index The index of the entity, which is required to be\n   *                        returned as item entity.\n   * @return {object}       containing applicable API methods.\n   * @private\n   */\n  itemCustomEntity = function (index) {\n    var api = Object.create(null);\n    // Access the parent document.\n    api.parentDocument = () => methods;\n    // Markup this entity.\n    api.markup = (beginMarker, endMarker) => markings.push([customEntities[index][0], customEntities[index][1], beginMarker, endMarker]);\n    // Output this entity or its properties using mapper function — `f`.\n    api.out = f => itmEntityOut(index, customEntities, docData, f);\n    // Access the parent sentence.\n    api.parentSentence = () => getParentItem(customEntities[index][0], sentences, itemSentence);\n    // Retun collection of tokens contained in this entity.\n    api.tokens = colTokens(customEntities[index][0], customEntities[index][1]);\n    // Index within the document.\n    api.index = () => index;\n    return api;\n  }; // itemCustomEntity()\n\n  // ### colSelectedCustomEntities\n  /**\n   *\n   * Makes collection of entities identified by the `selectedEntities` array.\n   *\n   * @param  {array} selectedCustomEntities The array of selected entities, using which\n   *                                        the collection is made.\n   * @return {object}                       containing applicable API methods.\n   * @private\n   */\n  colSelectedCustomEntities = function (selectedCustomEntities) {\n    var api = Object.create(null);\n    // Iterator.\n    api.each = f => selEach(f, selectedCustomEntities, itemCustomEntity);\n    // Filter.\n    api.filter = f => selFilter(f, selectedCustomEntities, itemCustomEntity, colSelectedCustomEntities);\n    // Item at `k`th index. If `k` is outside valid range, return `undefined` like JS.\n    api.itemAt = k => selGetItemAt(k, selectedCustomEntities, itemCustomEntity);\n    // Number of selected entities.\n    api.length = () => selectedCustomEntities.length;\n    // Output this collectionn of selected of entities as a reduced value\n    // using map/reduce functions — `f/g`.\n    api.out = (f, g) => selEntitiesOut(selectedCustomEntities, customEntities, docData, f, g);\n    return api;\n  }; // colSelectedCustomEntities()\n\n  // ### colCustomEntities\n  /**\n   *\n   * Makes collection of all the entities.\n   *\n   * @return {object} containing applicable API methods.\n   * @private\n   */\n  colCustomEntities = function () {\n    var api = Object.create(null);\n    // Iterator.\n    api.each = f => colEach(f, 0, customEntities.length - 1, itemCustomEntity);\n    // Filter.\n    api.filter = f => colFilter(f, 0, customEntities.length - 1, itemCustomEntity, colSelectedCustomEntities);\n    // Item at `k`th index. If `k` is outside valid range, return `undefined` like JS.\n    api.itemAt = k => colGetItemAt(k, 0, customEntities.length - 1, itemCustomEntity);\n    // Length of this collection.\n    api.length = () => customEntities.length;\n    // Output this collection of entities as a reduced value\n    // using map/reduce functions — `f/g`.\n    api.out = (f, g) => colEntitiesOut(customEntities, docData, f, g);\n    return api;\n  }; // colCustomEntities()\n\n  // <hr/>\n\n  // ## Sentence\n  // **Item, Collection, and Selection APIs.**\n\n  // ### itemSentence\n  /**\n   *\n   * Makes item of the sentence specified by `index` of the sentence.\n   *\n   * @param  {number} index The index of the sentence.\n   * @return {object}       containing applicable API methods.\n   * @private\n   */\n  itemSentence = function (index) {\n    var api = Object.create(null);\n    // Access the parent document.\n    api.parentDocument = () => methods;\n    // Markup this sentence.\n    api.markup = (beginMarker, endMarker) => markings.push([sentences[index][0], sentences[index][1], beginMarker, endMarker]);\n    // Output this sentence as text.\n    api.out = f => itmSentenceOut(index, docData, f, addons);\n    // Outputs the collection of entities, if any, contained in this sentence.\n    api.entities = () => colSelectedEntities(containedEntities(entities, sentences[index][0], sentences[index][1]));\n    // Outputs the collection of custom entities, if any, contained in this sentence.\n    api.customEntities = () => colSelectedCustomEntities(containedEntities(customEntities, sentences[index][0], sentences[index][1]));\n    // Outputs the collection of tokens in this sentence.\n    api.tokens = colTokens(sentences[index][0], sentences[index][1]);\n    // Index within the document.\n    api.index = () => index;\n    return api;\n  }; // itemSentence()\n\n  // ### colSentences\n  /**\n   *\n   * Makes collection of sentences in this document.\n   *\n   * @return {object} containing applicable API methods.\n   * @private\n   */\n  colSentences = function () {\n    var api = Object.create(null);\n    // Iterator.\n    api.each = f => colEach(f, 0, sentences.length - 1, itemSentence);\n    // Item at `k`th index. If `k` is outside valid range, return `undefined` like JS.\n    api.itemAt = k => colGetItemAt(k, 0, sentences.length - 1, itemSentence);\n    // Length of this collection.\n    api.length = () => sentences.length;\n    // Output this collection of sentences as an array of strings.\n    api.out = f => colSentencesOut(docData, f, addons);\n    return api;\n  }; // colSentences()\n\n  // <hr/>\n\n  // ### contextualVectors\n  /**\n   *\n   * Makes a JSON of contextually relevant words in the winkNLP format.\n   *\n   * @return {string} containing the JSON.\n  */\n  // eslint-disable-next-line complexity\n  contextualVectors = function ({\n    lemma = true,\n    specificWordVectors = [],\n    similarWordVectors = false,\n    wordVectorsLimit = 0\n  } = {}) {\n    // Error handling!\n    if (docData.wordVectors === null) throw Error('wink-nlp: word vectors are not loaded: load them winkNLP\\'s instantiation time.');\n    if (!Array.isArray(specificWordVectors)) throw Error(`wink-nlp: expecting a valid Javascript array for similarWordVectos, instead found \"${typeof specificWordVectors}\".`);\n    if (!Number.isInteger(wordVectorsLimit) || wordVectorsLimit >= docData.wordVectors.size) throw Error('wink-nlp: invalid value or type encountered for wordVectorsLimit.');\n    if (lemma && !docData.currPipe.pos) throw Error('wink-nlp: Can\\'t create lemma vectors without pos: add a \"pos\" to NLP pipe.');\n    // Initialize contextual vectors.\n    const cv = Object.create(null);\n    // Following properties are constants, therefore can be directly copied.\n    cv.precision = docData.wordVectors.precision;\n    cv.l2NormIndex = docData.wordVectors.l2NormIndex;\n    cv.wordIndex = docData.wordVectors.wordIndex;\n    cv.dimensions = docData.wordVectors.dimensions;\n    cv.unkVector = docData.wordVectors.unkVector.slice(0);\n    // Following properties will be determined on the basis of the context.\n    cv.size = 0;\n    cv.words = [];\n    cv.vectors = Object.create(null);\n    // Shortcut all word vectors.\n    const awvs = docData.wordVectors.vectors;\n\n    // Extract all document's tokens.\n    const docTokens = colTokens(0, docData.numOfTokens - 1)().out().map(t => t.toLowerCase());\n    let docTokensLemma = [];\n    if (lemma) docTokensLemma = colTokens(0, docData.numOfTokens - 1)().out(its.lemma).map(t => t.toLowerCase());\n\n    // NOTE: For UNK words an all zero vector is set up, with `l2Norm = 0`, which may be used in as.vector helper\n    // to detect an UNK word.\n    for (let i = 0; i < docTokens.length; i += 1) cv.vectors[docTokens[i]] = (awvs[docTokens[i]] || cv.unkVector).slice(0);\n    for (let i = 0; i < docTokensLemma.length; i += 1) cv.vectors[docTokensLemma[i]] = (awvs[docTokensLemma[i]] || cv.unkVector).slice(0);\n    for (let i = 0; i < specificWordVectors.length; i += 1) {\n      const spWord = specificWordVectors[i] ? specificWordVectors[i].toString().trim() : false;\n      if (spWord) cv.vectors[specificWordVectors[i]] = (awvs[specificWordVectors[i]] || cv.unkVector).slice(0);\n    }\n    if (similarWordVectors) {\n      // Extract similar words on the basis of shortest Manhattan distance.\n      const allUniqueTokens = Object.keys(cv.vectors);\n      // Set up similar words array, with the size of all unique tokens.\n      const similarWords = new Array(allUniqueTokens.length);\n      // Placeholder for maintaining the similarity score based on Manhattan distance.\n      const similarWordsScore = new Array(allUniqueTokens.length);\n      // Initialize to a large distance!\n      similarWordsScore.fill(1000000);\n\n      // Initialize contextual vectors size i.e. vocab.\n      cv.size = allUniqueTokens.length;\n\n      // Now search each one of them in the entire word vectors space.\n      // Keep updating the smallest distance.\n      for (let i = 0; i < allUniqueTokens.length; i += 1) {\n        const cwv = cv.vectors[allUniqueTokens[i]];\n        for (const word in awvs) {\n          // eslint-disable-line guard-for-in\n          if (word === allUniqueTokens[i]) continue; // eslint-disable-line no-continue\n          const wv = awvs[word];\n          let distance = 0;\n          for (let k = 0; k < cv.dimensions && distance < similarWordsScore[i]; k += 1) {\n            distance += Math.abs(cwv[k] - wv[k]);\n          } // Mahattan distance computation loop.\n\n          if (distance < similarWordsScore[i]) {\n            similarWordsScore[i] = distance;\n            similarWords[i] = word;\n          }\n        } // Traversing all the word vectors.\n      } // Traversing all the tokens in the corpus.\n\n      // Update contextual vectors using the list of similar words; also update their size.\n      for (let i = 0; i < similarWords.length; i += 1) {\n        if (cv.vectors[similarWords[i]] === undefined) {\n          // Similar word must exist in `awvs`.\n          cv.vectors[similarWords[i]] = awvs[similarWords[i]].slice(0);\n          cv.size += 1;\n        }\n      }\n    } else cv.size = Object.keys(cv.vectors).length;\n\n    // Fill the balance space, if any, on the basis of wordVectorsLimit.\n    for (let i = 0; cv.size < wordVectorsLimit; i += 1) {\n      const word = docData.wordVectors.words[i];\n      if (!cv.vectors[word]) {\n        cv.vectors[word] = awvs[word].slice(0);\n        cv.size += 1;\n      }\n    }\n\n    // Sort words on the basis of their usage frequency.\n    cv.words = Object.keys(cv.vectors).map(w => ({\n      w: w,\n      i: cv.vectors[w][cv.wordIndex] < 0 ? Infinity : cv.vectors[w][cv.wordIndex]\n    })).sort((a, b) => a.i - b.i).map(o => o.w);\n\n    // Update the word index entry inside every vector.\n    for (let i = 0; i < cv.size; i += 1) cv.vectors[cv.words[i]][cv.wordIndex] = i;\n    return JSON.stringify(cv);\n  }; // contextualVectors()\n\n  // Published chainable methods.\n  methods.entities = colEntities;\n  methods.customEntities = colCustomEntities;\n  methods.isLexeme = isLexeme;\n  methods.isOOV = cache.isOOV;\n  methods.out = f => itmDocumentOut(docData, f, addons);\n  methods.sentences = colSentences;\n  methods.tokens = colTokens(0, docData.numOfTokens - 1);\n  methods.printTokens = () => printTokens(tokens, cache);\n\n  // Enusre that we make a deep copy of config before returning to avoid corruption!\n  methods.pipeConfig = () => JSON.parse(JSON.stringify(docData.currPipe));\n  methods.contextualVectors = contextualVectors;\n  return methods;\n};\nmodule.exports = doc;","map":{"version":3,"names":["containedEntities","require","getParentItem","colGetItemAt","selGetItemAt","colEach","selEach","colFilter","selFilter","itmTokenOut","colTokensOut","selTokensOut","itmEntityOut","colEntitiesOut","selEntitiesOut","itmSentenceOut","colSentencesOut","itmDocumentOut","printTokens","its","doc","docData","addons","cache","tokens","entities","customEntities","sentences","markings","colEntities","colCustomEntities","colTokens","colSentences","colSelectedEntities","colSelectedCustomEntities","colSelectedTokens","itemToken","itemEntity","itemCustomEntity","itemSentence","contextualVectors","isLexeme","lookup","methods","Object","create","index","api","parentDocument","parentEntity","parentCustomEntity","markup","beginMarker","endMarker","push","out","f","parentSentence","selectedTokens","each","filter","itemAt","k","length","g","start","end","selectedEntities","selectedCustomEntities","lemma","specificWordVectors","similarWordVectors","wordVectorsLimit","wordVectors","Error","Array","isArray","Number","isInteger","size","currPipe","pos","cv","precision","l2NormIndex","wordIndex","dimensions","unkVector","slice","words","vectors","awvs","docTokens","numOfTokens","map","t","toLowerCase","docTokensLemma","i","spWord","toString","trim","allUniqueTokens","keys","similarWords","similarWordsScore","fill","cwv","word","wv","distance","Math","abs","undefined","w","Infinity","sort","a","b","o","JSON","stringify","isOOV","pipeConfig","parse","module","exports"],"sources":["C:/Users/cheko/Desktop/Education/Freelance/criticowl-main/criticowl_frontend/node_modules/wink-nlp/src/doc-v2.js"],"sourcesContent":["//     wink-nlp\n//\n//     Copyright (C) GRAYPE Systems Private Limited\n//\n//     This file is part of “wink-nlp”.\n//\n//     Permission is hereby granted, free of charge, to any\n//     person obtaining a copy of this software and\n//     associated documentation files (the \"Software\"), to\n//     deal in the Software without restriction, including\n//     without limitation the rights to use, copy, modify,\n//     merge, publish, distribute, sublicense, and/or sell\n//     copies of the Software, and to permit persons to\n//     whom the Software is furnished to do so, subject to\n//     the following conditions:\n//\n//     The above copyright notice and this permission notice\n//     shall be included in all copies or substantial\n//     portions of the Software.\n//\n//     THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF\n//     ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED\n//     TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A\n//     PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL\n//     THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,\n//     DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF\n//     CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN\n//     CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER\n//     DEALINGS IN THE SOFTWARE.\n\n//\n\n/* eslint-disable no-underscore-dangle */\n/* eslint-disable no-console */\n\nvar containedEntities = require( './contained-entities.js' );\n\n// ### Helper Functions\n\n// Get **item at** collection, selection & parent.\nvar getParentItem = require( './api/get-parent-item.js' );\nvar colGetItemAt = require( './api/col-get-item.js' );\nvar selGetItemAt = require( './api/sel-get-item.js' );\n\n// **Each** iterator for collection & selection.\nvar colEach = require( './api/col-each.js' );\nvar selEach = require( './api/sel-each.js' );\n\n// **Filter** for collection & selection.\nvar colFilter = require( './api/col-filter.js' );\nvar selFilter = require( './api/sel-filter.js' );\n\n// **Token's out** for item, collection & selection.\nvar itmTokenOut = require( './api/itm-token-out.js' );\nvar colTokensOut = require( './api/col-tokens-out.js' );\nvar selTokensOut = require( './api/sel-tokens-out.js' );\n\n// **Entity's out** for item, collection & selection.\nvar itmEntityOut = require( './api/itm-entity-out.js' );\nvar colEntitiesOut = require( './api/col-entities-out.js' );\nvar selEntitiesOut = require( './api/sel-entities-out.js' );\n\n// **Sentence's out** for item, collection & selection.\nvar itmSentenceOut = require( './api/itm-sentence-out.js' );\nvar colSentencesOut = require( './api/col-sentences-out.js' );\n\n// **Document's out** for item.\nvar itmDocumentOut = require( './api/itm-document-out.js' );\n\n// Print tokens, it is primarily for command line output.\nvar printTokens = require( './api/print-tokens.js' );\n\nvar its = require( './its.js' );\n\n// <hr/>\n\n// # Doc\n/**\n *\n * The wink-nlp **doc**ument – constructed in `wink-nlp.js` – publishes the\n * developer APIs.\n *\n * @param  {object} docData     It encapsulates the document data.\n * @param  {object} addons      The model's addon, may contain word vectors, stemmer etc.\n * @return {object}             conatining APIs.\n * @private\n */\nvar doc = function ( docData, addons ) {\n  // Extract `cache` as it is frequently accessed.\n  var cache = docData.cache;\n\n  // Document's tokens; each token is represented as an array of numbers:\n  // ```\n  // [\n  //   hash, // of tokenized lexeme\n  //   (nox) + preceding spaces, // expansion's normal\n  //   pos + lemma, // pos & lemma are contextual\n  //   entity + sentence // 12bit + 20bits\n  // ]\n  // ```\n  var tokens = docData.tokens;\n\n  // Entities — sorted as array of `[ start, end, entity type ].`\n  var entities = docData.entities;\n  var customEntities = docData.customEntities;\n\n  // Sentences — sorted as array of pairs of `[ start, end ]` pointing to the `tokens`.\n  var sentences = docData.sentences;\n\n  // Markings are 4-tuples of `start`, `end` **token indexes**,  and `begin & end markers`.\n  // The begin & end markers are used to markup the tokens specified.\n  var markings = docData.markings;\n\n\n  // #### API core functions:\n\n  // Collection APIs.\n  var colEntities;\n  var colCustomEntities;\n  var colTokens;\n  var colSentences;\n\n  // Selection — obtained via `filter` — APIs. It is also like a collection.\n  var colSelectedEntities;\n  var colSelectedCustomEntities;\n  var colSelectedTokens;\n\n  // Item APIs.\n  var itemToken;\n  var itemEntity;\n  var itemCustomEntity;\n  var itemSentence;\n\n  // Vectors API\n  var contextualVectors;\n\n  // Others.\n  var isLexeme = cache.lookup;\n\n  // The Document — Returned!\n  var methods = Object.create( null );\n\n  // ## Token\n  // **Item, Collection, and Selection APIs.**\n\n  // ### itemToken\n  /**\n   *\n   * Makes item of the token specified at `index`.\n   *\n   * @param  {number} index The index of the token, which is required to be returned as item token.\n   * @return {object}       containing applicable API methods.\n   * @private\n   */\n  itemToken = function ( index ) {\n    var api = Object.create( null );\n    // Access the parent document.\n    api.parentDocument = () => methods;\n    // Access the parent entity, **if any.**\n    api.parentEntity = () => getParentItem( index, entities, itemEntity );\n    // Access the parent cuustom entity, **if any.**\n    api.parentCustomEntity = () => getParentItem( index, customEntities, itemCustomEntity );\n    // Markup this token.\n    api.markup = ( beginMarker, endMarker ) => markings.push( [ index, index, beginMarker, endMarker ] );\n    // Output this token or its properties using mapper function — `f`.\n    api.out = ( f ) => itmTokenOut( index, docData, f, addons );\n    // Access the parent sentence.\n    api.parentSentence = () => getParentItem( index, sentences, itemSentence );\n    // Index within the document.\n    api.index = () => ( index );\n    return api;\n  }; // itemToken()\n\n  // ### colSelectedTokens\n  /**\n   *\n   * Makes collection of tokens identified by the `selectedTokens` array.\n   *\n   * @param  {array} selectedTokens The array of selected tokens, using which the\n   *                                collection is made.\n   * @return {object}               containing applicable API methods.\n   * @private\n   */\n  colSelectedTokens = function ( selectedTokens ) {\n    var api = Object.create( null );\n    // Iterator.\n    api.each = ( f ) => selEach( f, selectedTokens, itemToken );\n    // Filter.\n    api.filter = ( f ) => selFilter( f, selectedTokens, itemToken, colSelectedTokens );\n    // Item at `k`th index. If `k` is outside valid range, return `undefined` like JS.\n    api.itemAt = ( k ) => selGetItemAt( k, selectedTokens, itemToken );\n    // Number of selected tokens.\n    api.length = () => ( selectedTokens.length );\n    // Output this collection of selected tokens as a reduced values or properties\n    // using map/reduce functions — `f/g`.\n    api.out = ( f, g ) => selTokensOut( selectedTokens, docData, f, g, addons );\n    return api;\n  }; // colTokens()\n\n  // ### colTokens\n  /**\n   *\n   * Makes collection of tokens beginning from `start` index to `end` index.\n   *\n   * @param  {number} start The start index.\n   * @param  {number} end   The end index.\n   * @return {object}       containing applicable API methods.\n   * @private\n   */\n  colTokens = function ( start, end ) {\n    return (\n      function () {\n        var api = Object.create( null );\n        // Iterator.\n        api.each = ( f ) => colEach( f, start, end, itemToken );\n        // Filter.\n        api.filter = ( f ) => colFilter( f, start, end, itemToken, colSelectedTokens );\n        // Item at `k`th index. If `k` is outside valid range, return `undefined` like JS.\n        // No need to handle relative indexing as `colGetItemAt` handles it.\n        api.itemAt = ( k ) => colGetItemAt( k, start, end, itemToken );\n        // Length of this collection.\n        api.length = () => ( end - start + 1 );\n        // Output this token collection as a reduced values or properties using\n        // map/reduce functions — `f/g`.\n        api.out = ( f, g ) => colTokensOut( start, end, docData, f, g, addons );\n\n        return api;\n      }\n    );\n  }; // colTokens()\n\n  // <hr/>\n\n  // ## Entity\n  // **Item, Collection, and Selection APIs.**\n\n  // ### itemEntity\n  /**\n   *\n   * Makes item of the entity specified at `index`.\n   *\n   * @param  {number} index The index of the entity, which is required to be\n   *                        returned as item entity.\n   * @return {object}       containing applicable API methods.\n   * @private\n   */\n  itemEntity = function ( index ) {\n    var api = Object.create( null );\n    // Access the parent document.\n    api.parentDocument = () => methods;\n    // Markup this entity.\n    api.markup = ( beginMarker, endMarker ) => markings.push( [ entities[ index ][ 0 ], entities[ index ][ 1 ], beginMarker, endMarker ] );\n    // Output this entity or its properties using mapper function — `f`.\n    api.out = ( f ) => itmEntityOut( index, entities, docData, f );\n    // Access the parent sentence.\n    api.parentSentence =  () => getParentItem( entities[ index ][ 0 ], sentences, itemSentence );\n    // Retun collection of tokens contained in this entity.\n    api.tokens = colTokens( entities[ index ][ 0 ], entities[ index ][ 1 ] );\n    // Index within the document.\n    api.index = () => ( index );\n    return api;\n  }; // itemEntity()\n\n  // ### colSelectedEntities\n  /**\n   *\n   * Makes collection of entities identified by the `selectedEntities` array.\n   *\n   * @param  {array} selectedEntities The array of selected entities, using which\n   *                                  the collection is made.\n   * @return {object}                 containing applicable API methods.\n   * @private\n   */\n  colSelectedEntities = function ( selectedEntities ) {\n    var api = Object.create( null );\n    // Iterator.\n    api.each = ( f ) => selEach( f, selectedEntities, itemEntity );\n    // Filter.\n    api.filter = ( f ) => selFilter( f, selectedEntities, itemEntity, colSelectedEntities );\n    // Item at `k`th index. If `k` is outside valid range, return `undefined` like JS.\n    api.itemAt = ( k ) => selGetItemAt( k, selectedEntities, itemEntity );\n    // Number of selected entities.\n    api.length = () => ( selectedEntities.length );\n    // Output this collectionn of selected of entities as a reduced value\n    // using map/reduce functions — `f/g`.\n    api.out = ( f, g ) => selEntitiesOut( selectedEntities, entities, docData, f, g );\n    return api;\n  }; // colSelectedEntities()\n\n  // ### colEntities\n  /**\n   *\n   * Makes collection of all the entities.\n   *\n   * @return {object} containing applicable API methods.\n   * @private\n   */\n  colEntities = function () {\n    var api = Object.create( null );\n    // Iterator.\n    api.each = ( f ) => colEach( f, 0, entities.length - 1, itemEntity );\n    // Filter.\n    api.filter = ( f ) => colFilter( f, 0, entities.length - 1, itemEntity, colSelectedEntities );\n    // Item at `k`th index. If `k` is outside valid range, return `undefined` like JS.\n    api.itemAt = ( k ) => colGetItemAt( k, 0, ( entities.length - 1 ), itemEntity );\n    // Length of this collection.\n    api.length = () => ( entities.length );\n    // Output this collection of entities as a reduced value\n    // using map/reduce functions — `f/g`.\n    api.out = ( f, g ) => colEntitiesOut( entities, docData, f, g );\n    return api;\n  }; // colEntities()\n\n  // <hr/>\n\n  // ## Entity\n  // **Item, Collection, and Selection APIs.**\n\n  // ### itemCustomEntity\n  /**\n   *\n   * Makes item of the entity specified at `index`.\n   *\n   * @param  {number} index The index of the entity, which is required to be\n   *                        returned as item entity.\n   * @return {object}       containing applicable API methods.\n   * @private\n   */\n  itemCustomEntity = function ( index ) {\n    var api = Object.create( null );\n    // Access the parent document.\n    api.parentDocument = () => methods;\n    // Markup this entity.\n    api.markup = ( beginMarker, endMarker ) => markings.push( [ customEntities[ index ][ 0 ], customEntities[ index ][ 1 ], beginMarker, endMarker ] );\n    // Output this entity or its properties using mapper function — `f`.\n    api.out = ( f ) => itmEntityOut( index, customEntities, docData, f );\n    // Access the parent sentence.\n    api.parentSentence =  () => getParentItem( customEntities[ index ][ 0 ], sentences, itemSentence );\n    // Retun collection of tokens contained in this entity.\n    api.tokens = colTokens( customEntities[ index ][ 0 ], customEntities[ index ][ 1 ] );\n    // Index within the document.\n    api.index = () => ( index );\n    return api;\n  }; // itemCustomEntity()\n\n  // ### colSelectedCustomEntities\n  /**\n   *\n   * Makes collection of entities identified by the `selectedEntities` array.\n   *\n   * @param  {array} selectedCustomEntities The array of selected entities, using which\n   *                                        the collection is made.\n   * @return {object}                       containing applicable API methods.\n   * @private\n   */\n  colSelectedCustomEntities = function ( selectedCustomEntities ) {\n    var api = Object.create( null );\n    // Iterator.\n    api.each = ( f ) => selEach( f, selectedCustomEntities, itemCustomEntity );\n    // Filter.\n    api.filter = ( f ) => selFilter( f, selectedCustomEntities, itemCustomEntity, colSelectedCustomEntities );\n    // Item at `k`th index. If `k` is outside valid range, return `undefined` like JS.\n    api.itemAt = ( k ) => selGetItemAt( k, selectedCustomEntities, itemCustomEntity );\n    // Number of selected entities.\n    api.length = () => ( selectedCustomEntities.length );\n    // Output this collectionn of selected of entities as a reduced value\n    // using map/reduce functions — `f/g`.\n    api.out = ( f, g ) => selEntitiesOut( selectedCustomEntities, customEntities, docData, f, g );\n    return api;\n  }; // colSelectedCustomEntities()\n\n  // ### colCustomEntities\n  /**\n   *\n   * Makes collection of all the entities.\n   *\n   * @return {object} containing applicable API methods.\n   * @private\n   */\n  colCustomEntities = function () {\n    var api = Object.create( null );\n    // Iterator.\n    api.each = ( f ) => colEach( f, 0, customEntities.length - 1, itemCustomEntity );\n    // Filter.\n    api.filter = ( f ) => colFilter( f, 0, customEntities.length - 1, itemCustomEntity, colSelectedCustomEntities );\n    // Item at `k`th index. If `k` is outside valid range, return `undefined` like JS.\n    api.itemAt = ( k ) => colGetItemAt( k, 0, ( customEntities.length - 1 ), itemCustomEntity );\n    // Length of this collection.\n    api.length = () => ( customEntities.length );\n    // Output this collection of entities as a reduced value\n    // using map/reduce functions — `f/g`.\n    api.out = ( f, g ) => colEntitiesOut( customEntities, docData, f, g );\n    return api;\n  }; // colCustomEntities()\n\n  // <hr/>\n\n  // ## Sentence\n  // **Item, Collection, and Selection APIs.**\n\n  // ### itemSentence\n  /**\n   *\n   * Makes item of the sentence specified by `index` of the sentence.\n   *\n   * @param  {number} index The index of the sentence.\n   * @return {object}       containing applicable API methods.\n   * @private\n   */\n  itemSentence = function ( index ) {\n    var api = Object.create( null );\n    // Access the parent document.\n    api.parentDocument = () => methods;\n    // Markup this sentence.\n    api.markup = ( beginMarker, endMarker ) => markings.push( [ sentences[ index ][ 0 ], sentences[ index ][ 1 ], beginMarker, endMarker ] );\n    // Output this sentence as text.\n    api.out = ( f ) => itmSentenceOut( index, docData, f, addons );\n    // Outputs the collection of entities, if any, contained in this sentence.\n    api.entities = () => colSelectedEntities( containedEntities( entities, sentences[ index ][ 0 ], sentences[ index ][ 1 ] ) );\n    // Outputs the collection of custom entities, if any, contained in this sentence.\n    api.customEntities = () => colSelectedCustomEntities( containedEntities( customEntities, sentences[ index ][ 0 ], sentences[ index ][ 1 ] ) );\n    // Outputs the collection of tokens in this sentence.\n    api.tokens = colTokens( sentences[ index ][ 0 ], sentences[ index ][ 1 ] );\n    // Index within the document.\n    api.index = () => ( index );\n    return api;\n  }; // itemSentence()\n\n  // ### colSentences\n  /**\n   *\n   * Makes collection of sentences in this document.\n   *\n   * @return {object} containing applicable API methods.\n   * @private\n   */\n  colSentences = function () {\n    var api = Object.create( null );\n    // Iterator.\n    api.each = ( f ) => colEach( f, 0, sentences.length - 1, itemSentence );\n    // Item at `k`th index. If `k` is outside valid range, return `undefined` like JS.\n    api.itemAt = ( k ) => colGetItemAt( k, 0, ( sentences.length - 1 ), itemSentence );\n    // Length of this collection.\n    api.length = () => ( sentences.length );\n    // Output this collection of sentences as an array of strings.\n    api.out = ( f ) => colSentencesOut( docData, f, addons );\n    return api;\n  }; // colSentences()\n\n  // <hr/>\n\n  // ### contextualVectors\n  /**\n   *\n   * Makes a JSON of contextually relevant words in the winkNLP format.\n   *\n   * @return {string} containing the JSON.\n  */\n  // eslint-disable-next-line complexity\n  contextualVectors = function ( { lemma = true, specificWordVectors = [], similarWordVectors = false, wordVectorsLimit = 0 } = {} ) {\n    // Error handling!\n    if ( docData.wordVectors === null )\n      throw Error( 'wink-nlp: word vectors are not loaded: load them winkNLP\\'s instantiation time.' );\n    if ( !Array.isArray( specificWordVectors ) )\n      throw Error( `wink-nlp: expecting a valid Javascript array for similarWordVectos, instead found \"${typeof specificWordVectors}\".`);\n    if ( !Number.isInteger( wordVectorsLimit ) || wordVectorsLimit >= docData.wordVectors.size )\n      throw Error( 'wink-nlp: invalid value or type encountered for wordVectorsLimit.' );\n    if ( lemma && !docData.currPipe.pos )\n      throw Error( 'wink-nlp: Can\\'t create lemma vectors without pos: add a \"pos\" to NLP pipe.' );\n    // Initialize contextual vectors.\n    const cv = Object.create( null );\n    // Following properties are constants, therefore can be directly copied.\n    cv.precision = docData.wordVectors.precision;\n    cv.l2NormIndex = docData.wordVectors.l2NormIndex;\n    cv.wordIndex = docData.wordVectors.wordIndex;\n    cv.dimensions = docData.wordVectors.dimensions;\n    cv.unkVector = docData.wordVectors.unkVector.slice( 0 );\n    // Following properties will be determined on the basis of the context.\n    cv.size = 0;\n    cv.words = [];\n    cv.vectors = Object.create( null );\n    // Shortcut all word vectors.\n    const awvs = docData.wordVectors.vectors;\n\n    // Extract all document's tokens.\n    const docTokens = colTokens( 0, docData.numOfTokens - 1 )()\n                      .out()\n                      .map( ( t ) => t.toLowerCase() );\n    let docTokensLemma = [];\n    if ( lemma ) docTokensLemma = colTokens( 0, docData.numOfTokens - 1 )()\n                                           .out( its.lemma )\n                                           .map( ( t ) => t.toLowerCase() );\n\n    // NOTE: For UNK words an all zero vector is set up, with `l2Norm = 0`, which may be used in as.vector helper\n    // to detect an UNK word.\n    for ( let i = 0; i < docTokens.length; i += 1 ) cv.vectors[ docTokens[ i ] ] = ( awvs[ docTokens[ i ] ] || cv.unkVector ).slice( 0 );\n    for ( let i = 0; i < docTokensLemma.length; i += 1 ) cv.vectors[ docTokensLemma[ i ] ] = ( awvs[ docTokensLemma[ i ] ] || cv.unkVector ).slice( 0 );\n    for ( let i = 0; i < specificWordVectors.length; i += 1 ) {\n      const spWord = ( specificWordVectors[ i ] ) ? specificWordVectors[ i ].toString().trim() : false;\n      if ( spWord )\n        cv.vectors[ specificWordVectors[ i ] ] = ( awvs[ specificWordVectors[ i ] ] || cv.unkVector ).slice( 0 );\n    }\n\n    if ( similarWordVectors ) {\n      // Extract similar words on the basis of shortest Manhattan distance.\n      const allUniqueTokens = Object.keys( cv.vectors );\n      // Set up similar words array, with the size of all unique tokens.\n      const similarWords = new Array( allUniqueTokens.length );\n      // Placeholder for maintaining the similarity score based on Manhattan distance.\n      const similarWordsScore = new Array( allUniqueTokens.length );\n      // Initialize to a large distance!\n      similarWordsScore.fill( 1000000 );\n\n      // Initialize contextual vectors size i.e. vocab.\n      cv.size = allUniqueTokens.length;\n\n      // Now search each one of them in the entire word vectors space.\n      // Keep updating the smallest distance.\n      for ( let i = 0; i < allUniqueTokens.length; i += 1 ) {\n        const cwv = cv.vectors[ allUniqueTokens[ i ] ];\n\n        for ( const word in awvs ) { // eslint-disable-line guard-for-in\n          if ( word === allUniqueTokens[ i ] ) continue; // eslint-disable-line no-continue\n          const wv = awvs[ word ];\n          let distance = 0;\n\n          for ( let k = 0; k < cv.dimensions && distance < similarWordsScore[ i ]; k += 1 ) {\n            distance += Math.abs( cwv[ k ] - wv[ k ] );\n          } // Mahattan distance computation loop.\n\n          if ( distance < similarWordsScore[ i ] ) {\n            similarWordsScore[ i ] = distance;\n            similarWords[ i ] = word;\n          }\n        } // Traversing all the word vectors.\n      } // Traversing all the tokens in the corpus.\n\n      // Update contextual vectors using the list of similar words; also update their size.\n      for ( let i = 0; i < similarWords.length; i += 1 ) {\n        if ( cv.vectors[ similarWords[ i ] ] === undefined ) {\n          // Similar word must exist in `awvs`.\n          cv.vectors[ similarWords[ i ] ] = awvs[ similarWords[ i ] ].slice( 0 );\n          cv.size += 1;\n        }\n      }\n\n    } else cv.size = Object.keys( cv.vectors ).length;\n\n    // Fill the balance space, if any, on the basis of wordVectorsLimit.\n    for ( let i = 0; cv.size < wordVectorsLimit; i += 1 ) {\n      const word = docData.wordVectors.words[ i ];\n      if ( !cv.vectors[ word ] ) {\n        cv.vectors[ word ] = awvs[ word ].slice( 0 );\n        cv.size += 1;\n      }\n    }\n\n    // Sort words on the basis of their usage frequency.\n    cv.words = Object.keys( cv.vectors )\n                        .map( ( w ) => ( { w: w, i: (cv.vectors[ w ][ cv.wordIndex ] < 0 ) ? Infinity : cv.vectors[ w ][ cv.wordIndex ] } ) )\n                        .sort( (a, b) => a.i - b.i )\n                        .map( ( o ) => o.w );\n\n    // Update the word index entry inside every vector.\n    for ( let i = 0; i < cv.size; i += 1 ) cv.vectors[ cv.words[ i ] ][ cv.wordIndex ] = i;\n\n    return JSON.stringify( cv );\n  }; // contextualVectors()\n\n  // Published chainable methods.\n  methods.entities = colEntities;\n  methods.customEntities = colCustomEntities;\n  methods.isLexeme = isLexeme;\n  methods.isOOV = cache.isOOV;\n  methods.out = ( f ) => itmDocumentOut( docData, f, addons );\n  methods.sentences = colSentences;\n  methods.tokens = colTokens( 0, docData.numOfTokens - 1 );\n\n  methods.printTokens = () => printTokens( tokens, cache );\n\n  // Enusre that we make a deep copy of config before returning to avoid corruption!\n  methods.pipeConfig = () => JSON.parse( JSON.stringify( docData.currPipe ) );\n\n  methods.contextualVectors = contextualVectors;\n\n  return methods;\n};\n\nmodule.exports = doc;\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"script","externalDependencies":[]}